# 网络编程

## ***1. 概念***
### 1.1 计算机网络的组成
1. 硬件
    - 主机, 光纤, 交换设备(路由器, 交换机)
2. 软件
    - 操作系统, 邮件收发软件, FTP程序
3. 协议
    - http, tcp, udp, ip...
### 1.2 计算机网络按分布范围分类
1. 广域网(WAN)
2. 局域网(LAN)
3. 个人区域网(PAN)personal area network
### 1.3 名词解释
1. mac地址: 网卡的物理地址
2. ip地址: 
    - 在网络中识别机器的逻辑地址, 一定要与具体的主机进行映射(关联)
    - 192.168.10.102 点分十进制字符串
    - 192.168.10: 网络号(网段)
    - 102: 主机号
    - 子网掩码(用于屏蔽主机号)
        1. 用于获取ip地址中的网络号
        2. 255.255.255.0
        3. ip & 子网掩码 = 网络号
        4. ip & ~子网掩码 = 主机号
3. 端口号
    1. 标识使用网络的进程, 决定数据到底发送给哪个进程
    2. 端口号一般为16位, 范围(0 ~ 65535)**0 ~ 1023已经永久分配给特定的进程**
4. 网关
    - **一般用路由器作为网关**
5. DNS服务器
    - 将域名解析为ip地址
6. DHCP服务器
    - 自动分配ip地址
---
## ***2. 网络通信原理***
### 2.1 硬件
#### 2.1.1 交换机
1. 说明: 他是一种网络硬件, 通过报文交换接收和转发数据到目标设备, 它能够在计算机网络上连接不同的设备, 
2. **它工作在数据链路层**
3. 工作过程
    1. A主机封装好网络数据包(包含地址信息与数据), 将数据发送给交换机
    2. 交换机解析目标mac地址信息
    3. 交换机查mac地址与端口映射表, 找到目标mac地址所对应的端口
    4. 交换机通过目标端口将数据转发出去, 到达B主机
    5. ARP协议: 根据ip地址找到对应的mac地址
    6. RARP协议: 根据mac地址找到ip地址
#### 2.1.2 路由器
1. 说明: 一种电讯网络设备, 提供路由与传送两种重要机制
    1. 可以决定数据包由来源端所经过的路径, (host到host之间的传输路径), 这个过程称为路由
    2. 将路由器输入端的数据包移送至适当路由器输出端(在路由器内部进行), 称为传送
2. **与交换机区别**(个人感觉路由器用于远距离数据传输, 交换机用于局域网数据传输)
    1. 路由器在网络层[(第三层)](#222-层次结构), 而交换机(网桥)在数据链路层工作(第二层)
    2. 路由器能在多条路径中选择最佳路径, 在发送数据包时, 路由表会被一同发送, 该表存储了前往某一网络的最佳路径
    3. 路由器可连接超过两个以上的不同网络, 而交换机只能连接两个
    4. 路由器具有ip分享器功能, ，主要是让多台设备用同一条ADSL/光纤宽带线路来上网，功能包括共享IP，宽带管理，自动分配IP等等
3. nat: 网络地址转换
### 2.2 软件
#### 2.2.1 协议
#### 2.2.2 层次结构
<table>
    <tr>
        <td>OSI参考模型</td>
        <td>TCP/IP五层模型</td>
        <td>实际应用</td>
    </tr>
    <tr>
        <td>应用层</td>
        <td rowspan="3">应用层</td>
        <td rowspan="3">应用层</td>
    </tr>
    <tr>
        <td>表示层</td>
    </tr>
    <tr>
        <td>会话层</td>
    </tr>
    <tr>
        <td>传输层</td>
        <td>传输层</td>
        <td>传输层</td>
    </tr>
    <tr>
        <td>网络层</td>
        <td>网络层</td>
        <td>网络层</td>
    </tr>
    <tr>
        <td>数据链路层</td>
        <td>数据链路层</td>
        <td>数据链路层</td>
    </tr>
    <tr>
        <td>物理层</td>
        <td>物理层</td>
    </tr>
</table>

#### 2.2.3 数据收发过程各层对应的协议
---
## ***[3. TCP](../Class/10网络编程/1day自习/1socket/1serve.c)***
### 3.1 创建套接字
- `int socket(int domain, int type, int protocol)`
    - `@domain`: 指明通信域(通信域决定通信使用的网络协议族)
        1. `AF_UNIX`: 同一台计算机的两个进程通过文件系统进行通信, 要求文件系统路径名作为套接字的地址
        2. `AF_INET`: ipv4
        3. `AF_INET6`: ipv6
    - `@type`: 套接字类型
        1. `SOCK_STREAM`: TCP
        2. `SOCK_DGRAM`: UDP(不可靠)
### 3.2 绑定(**arpa/inet.h**)
#### 3.2.1 [ip信息结构体](../Class/10%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/2day/1teacher_code/005bind.md)
#### 3.2.2 [信息结构体初始化](../Class/10网络编程/2day/1teacher_code/005bind.md#补充指定内存块清空函数)
#### 3.2.3 [字节序转换](../Class/10网络编程/2day/1teacher_code/005bind.md#字节序转换)
#### 3.2.4 [ip信息转换](../Class/10网络编程/2day/1teacher_code/005bind.md#ip地址转换)
#### 3.2.5 绑定`bind`
### 3.3 监听请求
- `listen(sockfd, size)`: 让套接字变成监听套接字
### 3.4 接受请求: 得到连接套接字
- `accept`
### 3.5 连接
- `connect`
### 3.6 发送接收函数(**阻塞函数**)
- `recv`
- `send`
---
## ***4. 三次握手与四次挥手***
### 4.1 说明
- 三次握手就是TCP连接的创建过程, 四次挥手是TCP连接的断开过程
### 4.2 一些关键词
#### 规则
- 每个对应的标志位都有对应的序号
#### 4.2.1 序号
- seq: 源向目标发送的消息标记
#### 4.2.2 确认序号
- ack(acknowledge): 确认收到了消息
#### 4.2.3 标志位(包)
1. ACK: 确认标志
2. SYN: 同步标志(**由客户端第一次发出**)
### 4.3 大致过程
#### 4.3.1 三次握手
1. \[SYN_SENT\]C----->(SYN)----->S\[SYN_RECV\]   客户端向服务器发送请求
2. \[ESTABLISH_LISTEN\]S--->(ACK, SYN)-->C       服务器告知客户端他收到并接收你的请求
3. C---->(ACK)-->S\[ESTABLISH_LISTEN\]           让服务器知道客户端那边收到了服务器的同意并把信息发送出去(双方都知道对方能收到包了所以就不用发送包了)
#### 4.3.2 四次挥手(**由客户端主动发起**)
1. \[FIN_WAIT1\]C--->(FIN)------>S\[CLOSE_WAIT\]     向服务器挥手说我要终止通信
2. \[FIN_WAIT2\]S--->(ACK)------>C                   告诉客户端我这边收到了你的关闭请求
3. \[TIME_WAIT\]S--->(FIN)------>C\[LAST_ACK\]       问客户端那边能先关闭吗
4. C--->(ACK)------>S\[CLOSED\]                      客户端那边关闭并告知服务器, 服务器接收确认信息后关闭(这样双方都关闭了)
- **说明: 因为三次挥手就能确认双方都能接收到信息, 所以最后一次是告诉服务器让他断开连接**
### 4.4 **常见面试题**
#### 4.4.1 为什么TCP连接的时候是3次？2次不可以吗？
- **因为需要考虑连接时丢包的问题**，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据,  
而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)  
这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。  
如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，  
服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，  
客户端收到重发的报文段后会再次给服务端发送确认ack报文。
#### 4.4.2 为什么TCP连接的时候是3次，关闭的时候却是4次？
- ***因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了***，  
服务端还有没有数据发客户端是不知道的。  
而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，  
等这些数据发完了服务端才能给客户端发FIN报文  
(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)。
#### 4.4.3 为什么客户端发出第四次挥手的确认报文后要等**2MSL**的时间才能释放TCP连接？
- **这里同样是要考虑丢包的问题**,  
如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，  
这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。
---
## ***5. 一些问题***
### 5.1 [关于无法复制图片的问题](/Class/10网络编程/3day/newtest/2server.c)
- **一定不要使用strlen()作为write或read的参数(why?)**, 用ret收集send和recv获得的字符数量
### 5.2 [粘包问题](/Class/10网络编程/3day/3client_server/3server.c)
### 5.3 TCP如何做到数据可靠传输？
- 序列号与确认序列号，校验和(md5)，三次握手(**TCP段格式/包头组成**)
- 也就是保证数据有序, 保证数据可靠,
### 5.4 UDP如何实现可靠传输？
- 在应用层封装一个数据包，数据长度，md5校验，序号，要求回发确认包
### 5.5 UDP异常断网如何解决？
1. TCP连接
    - 两端建立TCP通信用于判断对方是否断网, 然后利用UDP来传送数据
2. 心跳包
    - 每隔一段时间发送一个包用于让对方知道你还在线
### 5.6 TCP长连接与短连接问题
1. 长连接就是保持服务端与客户端持续通信
2. 短连接就是服务端每次与客户端完成通信后断开连接(关闭不需要的通信)
### 5.7 **网络通信需要将本机字节序转换为网络字节序(host to network)**
---
## ***6. 常用linux命令***
1. nc(功能较telnet丰富)

        简介：
        nc是netcat的简写，是一个功能强大的网络工具。nc命令在linux系统中实际命令是ncat，nc是软连接到ncat。

        功能：
        实现任意TCP/UDP端口的侦听，nc可以作为server以TCP或UDP方式侦听指定端口实现任意TCP/UDP端口的侦听，nc可以作为server以TCP或UDP方式侦听指定端口
        端口的扫描，nc可以作为client发起TCP或UDP连接
        机器之间传输文件
        机器之间网络测速
        
        常用参数：
        1) -l
        用于指定nc将处于侦听模式。指定该参数，则意味着nc被当作server，侦听并接受连接，而非向其它地址发起连接。
        2) -p <port>
        暂未用到（老版本的nc可能需要在端口号前加-p参数，下面测试环境是centos6.6，nc版本是nc-1.84，未用到-p参数）
        3) -s 
        指定发送数据的源IP地址，适用于多网卡机 
        4) -u
        指定nc使用UDP协议，默认为TCP
        5) -v
        输出交互或出错信息，新手调试时尤为有用
        6）-w
        超时秒数，后面跟数字 
        7）-z
        表示zero，表示扫描时不发送任何数据
        
        示例（以下示例加上-u将变为UDP通信）：
        1）nc -zvw 2 192.168.11.55 8888
        判断是否能成功连接到192.168.11.55的8888端口，不发送任何数据，超时时间为2秒
        2）nc -l 9999
        开启TCP服务，端口为9999，能打印出接收到的数据，不会回发数据
        3）nc 192.168.11.55 8888
        向ip为192.168.11.55的8888端口发起TCP连接请求，成功后可收发数据             
2. telnet

        telnet命令主要用于远程登录主机，一般也可用来测试远端端口是否可用
        
        参数较为复杂，更多用于远程登录
        
        示例：
        1）telnet 192.168.11.55 8888
        向ip为192.168.11.55的8888端口发起TCP连接请求，成功后可收发数据
3. netstat

        简介：
        netstat 命令用于显示网络状态。
        利用 netstat 指令可让你得知整个 Linux 系统的网络情况。
        
        常用参数：
        1）-a 或 --all
        显示所有连线中的Socket。
        2）-c 或 --continuous
        持续列出网络状态。
        3）-h 或 --help 
        在线帮助。
        4）-l 或 --listening 
        显示监控中的服务器的Socket。
        5）-n 或 --numeric 
        直接使用IP地址，而不通过域名服务器。
        6）-p 或 --programs 
        显示正在使用Socket的程序识别码和程序名称。
        7）-t 或 --tcp 
        显示TCP传输协议的连线状况。
        8）-u 或 --udp 
        显示UDP传输协议的连线状况。
        
        示例：
        1）netstat -lntp
        查看当前开启tcp服务的ip地址以及程序
        2）netstat -anp
        查看当前所有的socket使用状态和对应的程序
4. `gcc -Wall(参数)`: 显示所有未显示的警告
5. `md5sum <文件>`: 获得文件的摘要算法(hash算法)
---	
## ***7. UDP***
1. `sendto`
    - [比较TCP通信, 最后结束与客户端通信时需要传送一个空数据告诉客户端没数据了, 可以关闭通信了](/Class/10网络编程/4day/4practice/2download_file/1server/1server.c)`sendto(sockfd, buf, 0, 0, (struct sockaddr *)&saddr, slen); `
2. `recvfrom`
---
##  ***8. 其他常见问题***