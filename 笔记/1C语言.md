# ***大端小端***
- **记住低对低是小端即可, arm大端, x86小端**
- 小端: 低地址对低数据位

        int main(int argc, char *argv[])
        {
            int i = 0x12345678;
            char *c = (char *)&i;

            printf("%x \n", *c);

            return 0;
        }
---
# ***考试错题***
1. C语言中，运算对象必须是整形数的运算符是 `%`
2. 表达式 `!x` 等价于 `x == 0`
---
# ***变量的内存分配图***
---
# ***什么是assert?***
---
# ***如何编写MAKEFILE***
1. 目标

        <target>: <依赖1> <依赖2>
            <指令>
2. 对象

        <obj> = <文件>
---
# **static的作用**
1. static修饰局部变量
    - 修饰前: 
        1. 变量**存放在栈种**, 程序结束后变量被自动释放 
        2. **未初始化的局部变量默认为随机值**
    - 修饰后: 
        1. 变量**存放在静态区(data/bss段)**
        2. ***被修饰的局部变量默认值为0**
2. static修饰全局变量
    - 修饰后
        1. 函数/变量的**作用域范围被限制在当前的文件中**
        2. extern无法查看static修饰的全局变量
# ***const的作用***
1. 常见的用途
    1. 定义const常量, 使其具有不可变性

            const int len = 100;
            int array[len];
    1. 修饰普通变量

            const int a; 
            int const a;
    2. 修饰指针变量

            const int *a; // 常量指针(指向常量的指针, *a 是一个常量, a是常量的地址)

            int const *a;
            a  = &num; // 可以执行
            *a = 10;   // error, const 修饰的是 *a
            ---------------------------------------
            int *const b = &num;
            b  = NULL;  // error, const修饰的是 b, 所以b不能改
            *b = 10     // 可以执行
            ---------------------------------------
            const int * const c = &num;
            int const * const c = &num;
            const int const * const c = &num;
            c  = NULL;   // error
            *c = 20;     // error
2. 好处
    1. 可以节省空间, 避免不必要的浪费
        - 编译器通常不为普通 const 常量分配存储空间，而是将它们保存在符号表中。const 定义常量从汇编 的角度来看，只是给出了对应的内存地址，而不是象#define 一样给出的是立即数，所以 const 定义的常 量在程序运行过程中只有一份拷贝，而#define 定义的常量在内存中有若干个拷贝。这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。
    2. 为函数重载提供了参考

            class A
            {
                void func(int i) {

                }
                void func(int i) const {    // 函数重载

                }
            }
# ***volatile作用?***
- 注意点
    1. 当读取一个非volatile修饰的变量时，为提高存取速度，编译器优化时有时会先把变量读取到一个寄存器中以后再取变量时，就直接从寄存器中取值
    2. 优化器在用到volatile变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份
    3. volatile适用于多线程应用中被几个任务共享的变量

# ***字符串与字符数组的区别***
- 字符串有`'\0'`

        字符串   char str[] = "abc"; // 默认有'\0'  sizeof(str) = 4;
        字符串   char str[] = {'a', 'b', 'c', '\0'}; sizeof(str) = 4
        字符数组 char str[] = {'a', 'b', 'c'};       sizeof(str) = 3

# ***sizeof注意点***
1. 当操作数为指针时，也是依赖于编译器，但一般为指针字节数为4；
2. 当操作数具有数组类型时，其结果是数组的总字节数。但是，如果操作数是函数中的数组形参或函数类型的形参时，sizeof给出其指针的大小；

# ***一级指针二级指针访问二维数组***

        int arr[][3] = {
                88,22,99,
                40,50,93,
                7,8,9
        };

        int main()
        {
            int row   = 3;
            int col   = 2;
            int *pi   = arr;  // &arr[0] 比较好, 这样偏移量就是一个二维数组元素大小
                              // 否则arr表示一整个二维数组大小
            int **pi2 = &pi;  // 二级指针表示
            printf("%d\n", *(pi + 1 * 3 + 2)); // 一级指针访问
            printf("%d\n", *(*(pi2) + 3 + 2)); // 二级指针访问
        }
# ***逗号表达式***
## 逗号表达式的要领
1.从左到右逐个计算；
2.逗号表达式作为一个整体，它的值为最后一个表达式的值；
3. 逗号表达式的优先级别在所有运算符中最低。

# ***指针***

        #include <stdio.h>

                           const char **argv
        int main(int argc, const char *argv[]) // argv表示是一个二级指针, 传入的是地址
        {
            // 定义 = 类型 + 名字 !!!
            // 类型 = 定义 - 名字 !!!
            // 数组名为其第一个元素的首地址
            // double a[4][4] 的类型为 double [4][4]
            // 二位数组每个元素为一个一维数组
            // [[][][][]] -> [[][][][]] -> [[][][][]] -> [[][][][]]
            // a 表示 &a[0]; 偏移一个单位偏移 一个一维数组大小 4 * 8 = 32;
            // &a 表示整个二维数组的地址, 偏移一个单位偏移 4 * 4 * 8 = 128个字节

            double a[4][4]; 
            printf("a: %ld a + 1: %ld 偏移了 4 * sizeof(double)\n", a, a+1);

            // a 表示到M首元素地址 &a表示整到M的地址
            // a + 1表示偏移了一 double (*)[4]的大小 也就是 + 4 * sizeof(double) = 32
            
            printf("&a: %ld &a + 1: %ld\n", &a, &a + 1);
            // &a表示整到M的地址, &a + 1 表示偏移整到M 
            // 也就是 + 4 * 4 * 8 = 128
            
            double (*p)[3];  // p 的类型为 double (*)[3]
            // 表示他是一个数组指针, 这个指向的数组中每个元素大小为一个double, 存在三个元素
            // 所以每偏移一个单位偏移 3 * 8 = 24;
            p = a; // a = double [4][4]
            // p类型 = double (*)[3] = 8 * 3 = 24;
            [[double][][]] -> [[][][]] -> [[][][]]

            printf("&p[3][1] - &a[3][1]: %d\n", &p[3][1] - &a[3][1]);
            // p[3][1] = *(*(p+3)+1) = 24 * 3 + 8 = 72 + 8 = 80
            // a[3][1] = *(*(a + 3) + 1) = 32 * 3 + 8 = 104
            // 80 - 104 = -24
            // -24 / 8 = -3

            return 0;
        }

# 各种类型字节大小

        16位编译器
        char ：1个字节
        char*(即指针变量): 2个字节
        short int : 2个字节
        int：  2个字节
        unsigned int : 2个字节
        float:  4个字节
        double:   8个字节
        long:   4个字节
        long long:  8个字节
        unsigned long:  4个字节


        32位编译器

        char ：1个字节
        char*（即指针变量）: 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理64位编译器）
        short int : 2个字节

        int：  4个字节
        unsigned int : 4个字节
        float:  4个字节
        double:   8个字节
        long:   4个字节
        long long:  8个字节
        unsigned long:  4个字节

        64位编译器
        char ：1个字节
        char*(即指针变量): 8个字节
        short int : 2个字节
        int：  4个字节
        unsigned int : 4个字节
        float:  4个字节
        double:   8个字节
        long:   8个字节
        long long:  8个字节
        unsigned long:  8个字节 