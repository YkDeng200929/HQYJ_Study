# ***大端小端***
- **记住低对低是小端即可, arm大端, x86小端**
- 小端: 低地址对低数据位

        int main(int argc, char *argv[])
        {
            int i = 0x12345678;
            char *c = (char *)&i;

            printf("%x \n", *c);

            return 0;
        }
---
# ***考试错题***
1. C语言中，运算对象必须是整形数的运算符是 `%`
2. 表达式 `!x` 等价于 `x == 0`
---
# ***变量的内存分配图***
---
# ***什么是assert?***
---
# ***如何编写MAKEFILE***
1. 目标

        <target>: <依赖1> <依赖2>
            <指令>
2. 对象

        <obj> = <文件>
---
# **static的作用**
1. static修饰局部变量
    - 修饰前: 
        1. 变量**存放在栈种**, 程序结束后变量被自动释放 
        2. **未初始化的局部变量默认为随机值**
    - 修饰后: 
        1. 变量**存放在静态区(data/bss段)**
        2. ***被修饰的局部变量默认值为0**
2. static修饰全局变量
    - 修饰后
        1. 函数/变量的**作用域范围被限制在当前的文件中**
        2. extern无法查看static修饰的全局变量
# **const的作用**
1. 常见的用途
    1. 定义const常量, 使其具有不可变性

            const int len = 100;
            int array[len];
    1. 修饰普通变量

            const int a; 
            int const a;
    2. 修饰指针变量

            const int *a; // 常量指针(指向常量的指针, *a 是一个常量, a是常量的地址)

            int const *a;
            a  = &num; // 可以执行
            *a = 10;   // error, const 修饰的是 *a
            ---------------------------------------
            int *const b = &num;
            b  = NULL;  // error, const修饰的是 b, 所以b不能改
            *b = 10     // 可以执行
            ---------------------------------------
            const int * const c = &num;
            int const * const c = &num;
            const int const * const c = &num;
            c  = NULL;   // error
            *c = 20;     // error
2. 好处
    1. 可以节省空间, 避免不必要的浪费
        - 编译器通常不为普通 const 常量分配存储空间，而是将它们保存在符号表中。const 定义常量从汇编 的角度来看，只是给出了对应的内存地址，而不是象#define 一样给出的是立即数，所以 const 定义的常 量在程序运行过程中只有一份拷贝，而#define 定义的常量在内存中有若干个拷贝。这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。
    2. 为函数重载提供了参考

            class A
            {
                void func(int i) {

                }
                void func(int i) const {    // 函数重载

                }
            }
# volatile作用?
- 注意点
    1. 当读取一个非volatile修饰的变量时，为提高存取速度，编译器优化时有时会先把变量读取到一个寄存器中以后再取变量时，就直接从寄存器中取值
    2. 优化器在用到volatile变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份
    3. volatile适用于多线程应用中被几个任务共享的变量

# 字符串与字符数组的区别
- 字符串有`'\0'`

        字符串   char str[] = "abc"; // 默认有'\0'  sizeof(str) = 4;
        字符串   char str[] = {'a', 'b', 'c', '\0'}; sizeof(str) = 4
        字符数组 char str[] = {'a', 'b', 'c'};       sizeof(str) = 3

# sizeof注意点
1. 当操作数为指针时，也是依赖于编译器，但一般为指针字节数为4；
2. 当操作数具有数组类型时，其结果是数组的总字节数。但是，如果操作数是函数中的数组形参或函数类型的形参时，sizeof给出其指针的大小；

# 一级指针二级指针访问二维数组

        int arr[][3] = {
                88,22,99,
                40,50,93,
                7,8,9
        };

        int main()
        {
            int row   = 3;
            int col   = 2;
            int *pi   = arr;  // &arr[0] 比较好, 这样偏移量就是一个二维数组元素大小
                              // 否则arr表示一整个二维数组大小
            int **pi2 = &pi;  // 二级指针表示
            printf("%d\n", *(pi + 1 * 3 + 2)); // 一级指针访问
            printf("%d\n", *(*(pi2) + 3 + 2)); // 二级指针访问
        }