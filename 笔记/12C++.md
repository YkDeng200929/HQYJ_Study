## [命名空间](../Class/11C%2B%2B/1day/1namespace.cpp)
### 为什么会出现命名空间这个概念?
- 把不同人写的变量集合(打包)成那个人的名字, 这样使用相同变量名时指定是哪个人的变量，这样就能避免同名变量冲突的问题
- 总的来说就是解决符号名称冲突
### 域作用符
- `::(variable)`**默认访问的是全局变量的值**
- `namespace::(variable)`**访问命名空间中变量的值**
### 命名空间中可以存放哪些内容
- 命名空间中可以定义变量, 也可以定义函数, 这些函数和变量只有该命名空间可以访问
### **命名空间注意点**
1. 若两个命名空间有相同的变量名或函数名, 则会出错

        namespace name1 {
            int a = 10;

            void show() {
                printf("Hello world\n");
            }
        }
        namespace name2 {
            void show() {
                printf("Hello world2\n");
            }
        } 
        using namespace name1;
        using namesapce name2; // error
2. 局部引用命名空间的变量
3. 命名空间中可以嵌套一个命名空间
4. 命名空间的取别名方式
5. **匿名命名空间**
## [函数](../Class/11C%2B%2B/1day/4functions.cpp)

## [引用](../Class/11C%2B%2B/1day/6cite.cpp)

## 函数重载

## 类成员初始化方式

### [初始化列表](../Class/11C%2B%2B/2day/2project/Circle.cpp)

### C++98标准下:

    struct Base
    {
        Base() : a(250) {}
        Base(int num) : a(num) {}

    int a;
        int b = 1;	// error: 类的非静态成员，必须在构造函数中进行初始化
        static int c = 0;	// error: 类的静态成员，必须在类的外部进行初始化
        static const double d = 3.14;	// 类的静态常量成员，但不是整形或者枚举，无法通过编译
        // 说明: 如果使用 g++ 可能发现就地初始化 double 类型的静态常量是可以通过编译的，不过这实际是 GNU 对 C++ 的一个扩展，并不遵从 C++ 标准。

    static const char* const e = "i am luffy";
        // 类的静态常量成员，但不是整形或者枚举，无法通过编译
        const static int f = 0;
    };

### C++11标准下类成员初始化

## [Template模板](../Class/11C%2B%2B/6day/1template.cpp)
- [template顺序表](../Class/11C%2B%2B/6day/3temp_seqlist_teach2.cpp)

## STL容器(**注意: 使用容器时需要包含头文件**)
1. [vector向量](../Class/11C%2B%2B/6day/4vector.cpp)
2. [列表](../Class/11C%2B%2B/6day/5list.cpp)

### new和cite
1. new
    1. 不要使用delete来释放不是new分配的内存。
    2. 不要使用delete释放同一个内存块两次。
    3. 如果使用new\[\]为数组分配内存，则应使用delete\[\]来释放。
    4. 如果使用new\[\]为一个实体分配内存，则应使用delete（没有方括号）来释放。
    5. 对空指针应用delete是安全的。
2. cite
---
## 其他
1. static
    - 修饰成员函数时, 不能访问非静态成员, 只能访问静态成员

        class A
        {
            fun1();
            static fun2()
            {
                func1(); // 无法调用
            }
        }
2. 你new多少个对象你就得delete多少个对象

        A *p = new A[100]; 说明new了100个对象
        所以得delete100次

3. &a不能作为左值, 因为这里的&不是引用, 而地址是一个确定的值, 不能作为左值

4. 如何判断两个对象是否为同一个对象?
    - 判断两个对象的地址是否相等即可

5. 运算符重载:

        1. obj.100 // 成员访问运算符不能重载, 这个要是重载了就乱套了
        2. !obj
        3. obj++
        4. obj,100


6. 函数重载与覆盖隐藏的区别
    - 覆盖隐藏是基于**不同类** 
    - 函数重载属于**同一个类**

7. 动态多态与静态多态
    - 动态多态: 在**运行**的时候**自动确定**被调用的函数
    - 静态多态: 在编译的时候确定被调用的函数

8. 抽象类的派生类也是抽象类
    - 抽象类概念: 里面含有纯虚函数的类
    - 纯虚函数概念: virtual 函数名=0; 只在类中定义而不做实现

9. **构造函数不能设置为虚函数**, 而且析构函数最好设置成虚函数, 否则不会发生动态多态而导致只会调用基类的析构函数, 从而有可能造成内存泄漏

10. 关于构造函数定义格式的说明，具体如下。
    1. 构造函数名必须与类名相同。
    2. 构造函数名的前面不需要设置返回值类型。
    3. 构造函数中无返回值，不能使用return返回。
    4. 构造函数的成员权限控制符一般设置为public。

11. 什么是`动态联编`什么是`静态联编`
    1. 静态联编
        - 数组在编译前就固定了大小
    2. 动态联编
        - 数组在使用时动态分配内存大小

                int array[] = new int [10];
                delete [] array;
12. 面向对象的思维
    1. 使程序(对比活字印刷)
        1. 可维护
        2. 可复用
        3. 可扩展
        4. 灵活性好
    2. 降低程序耦合度, 不同功能封装不同的类
13. [UML类图绘制](../../../resource/3.UML%E7%B1%BB%E5%9B%BE%E5%9B%BE%E7%A4%BA/1.UML%E7%B1%BB%E5%9B%BE%E7%A4%BA%E4%BE%8B.png)
    1. [类表示方法及接口表示方法](../../../resource/3.UML%E7%B1%BB%E5%9B%BE%E5%9B%BE%E7%A4%BA/2.%E7%B1%BB%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95.png)
    2. [实现接口表示方法](../../../resource/3.UML%E7%B1%BB%E5%9B%BE%E5%9B%BE%E7%A4%BA/3.%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95.png)
        - 虚线加上空心三角形
    3. [关联关系表示方式](../../../resource/3.UML%E7%B1%BB%E5%9B%BE%E5%9B%BE%E7%A4%BA/4.%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F.png)
        - 实心箭头
    4. [聚合关系表示方式](../../../resource/3.UML%E7%B1%BB%E5%9B%BE%E5%9B%BE%E7%A4%BA/5.%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95.png)
        - 空心菱形加实心箭头
    5. [合成关系表示方式](../../../resource/3.UML%E7%B1%BB%E5%9B%BE%E5%9B%BE%E7%A4%BA/6.%E5%90%88%E6%88%90%E5%85%B3%E7%B3%BB.png)
        - 实心菱形加实心箭头
    6. [依赖关系](../../../resource/3.UML%E7%B1%BB%E5%9B%BE%E5%9B%BE%E7%A4%BA/7.%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png)
        - 虚线双向箭头
    7. 继承关系
        - 空心三角形加上实心箭头