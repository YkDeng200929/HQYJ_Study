## [1. 命名空间](../Class/11C%2B%2B/1day/1namespace.cpp)
### 为什么会出现命名空间这个概念?
- 把不同人写的变量集合(打包)成那个人的名字, 这样使用相同变量名时指定是哪个人的变量，这样就能避免同名变量冲突的问题
- 总的来说就是解决符号名称冲突
### 域作用符
- `::(variable)`**默认访问的是全局变量的值**
- `namespace::(variable)`**访问命名空间中变量的值**
### 命名空间中可以存放哪些内容
- 命名空间中可以定义变量, 也可以定义函数, 这些函数和变量只有该命名空间可以访问
### **命名空间注意点**
1. 若两个命名空间有相同的变量名或函数名, 则会出错

        namespace name1 {
            int a = 10;

            void show() {
                printf("Hello world\n");
            }
        }
        namespace name2 {
            void show() {
                printf("Hello world2\n");
            }
        } 
        using namespace name1;
        using namesapce name2; // error
2. 局部引用命名空间的变量
3. 命名空间中可以嵌套一个命名空间
4. 命名空间的取别名方式
5. **匿名命名空间**
## [函数](../Class/11C%2B%2B/1day/4functions.cpp)

## 2. [引用](../Class/11C%2B%2B/1day/6cite.cpp)

## 3. 函数重载

## 4. 类成员初始化方式

### [初始化列表](../Class/11C%2B%2B/2day/2project/Circle.cpp)

### C++98标准下:

    struct Base
    {
        Base() : a(250) {}
        Base(int num) : a(num) {}

    int a;
        int b = 1;	// error: 类的非静态成员，必须在构造函数中进行初始化
        static int c = 0;	// error: 类的静态成员，必须在类的外部进行初始化
        static const double d = 3.14;	// 类的静态常量成员，但不是整形或者枚举，无法通过编译
        // 说明: 如果使用 g++ 可能发现就地初始化 double 类型的静态常量是可以通过编译的，不过这实际是 GNU 对 C++ 的一个扩展，并不遵从 C++ 标准。

    static const char* const e = "i am luffy";
        // 类的静态常量成员，但不是整形或者枚举，无法通过编译
        const static int f = 0;
    };

### C++11标准下类成员初始化

## 5. [Template模板](../Class/11C%2B%2B/6day/1template.cpp)
- [template顺序表](../Class/11C%2B%2B/6day/3temp_seqlist_teach2.cpp)

## 6. STL容器(**注意: 使用容器时需要包含头文件**)
1. [vector向量](../Class/11C%2B%2B/6day/4vector.cpp)
2. [列表](../Class/11C%2B%2B/6day/5list.cpp)

## 7. 其他
1. static
    - 修饰成员函数时, 不能访问非静态成员, 只能访问静态成员

        class A
        {
            fun1();
            static fun2()
            {
                func1(); // 无法调用
            }
        }
2. 你new多少个对象你就得delete多少个对象

        A *p = new A[100]; 说明new了100个对象
        所以得delete100次

3. &a不能作为左值, 因为这里的&不是引用, 而地址是一个确定的值, 不能作为左值

4. 如何判断两个对象是否为同一个对象?
    - 判断两个对象的地址是否相等即可

5. 运算符重载:

        1. obj.100 // 成员访问运算符不能重载, 这个要是重载了就乱套了
        2. !obj
        3. obj++
        4. obj,100


6. 函数重载与覆盖隐藏的区别
    - 覆盖隐藏是基于**不同类** 
    - 函数重载属于**同一个类**

7. 动态多态与静态多态
    - 动态多态: 在**运行**的时候**自动确定**被调用的函数
    - 静态多态: 在编译的时候确定被调用的函数

8. 抽象类的派生类也是抽象类
    - 抽象类概念: 里面含有纯虚函数的类
    - 纯虚函数概念: virtual 函数名=0; 只在类中定义而不做实现

9. **构造函数不能设置为虚函数**, 而且析构函数最好设置成虚函数, 否则不会发生动态多态而导致只会调用基类的析构函数, 从而有可能造成内存泄漏
