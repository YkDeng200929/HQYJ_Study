# Day1
---
## [命名空间](../Class/11C%2B%2B/1day/1namespace.cpp)
### 为什么会出现命名空间这个概念?
- 把不同人写的变量集合(打包)成那个人的名字, 这样使用相同变量名时指定是哪个人的变量，这样就能避免同名变量冲突的问题
- 总的来说就是解决符号名称冲突
### 域作用符
- `::(variable)`**默认访问的是全局变量的值**
- `namespace::(variable)`**访问命名空间中变量的值**
### 命名空间中可以存放哪些内容
- 命名空间中可以定义变量, 也可以定义函数, 这些函数和变量只有该命名空间可以访问
### **命名空间注意点**
1. 若两个命名空间有相同的变量名或函数名, 则会出错

        namespace name1 {
            int a = 10;

            void show() {
                printf("Hello world\n");
            }
        }
        namespace name2 {
            void show() {
                printf("Hello world2\n");
            }
        } 
        using namespace name1;
        using namesapce name2; // error
2. 局部引用命名空间的变量
3. 命名空间中可以嵌套一个命名空间
4. 命名空间的取别名方式
5. **匿名命名空间**
## [函数](../Class/11C%2B%2B/1day/4functions.cpp)

## 引用

## 函数重载

# Day2

## 类成员初始化

### [初始化列表](../Class/11C%2B%2B/2day/2project/Circle.cpp)

### C++98标准下:

    struct Base
    {
        Base() : a(250) {}
        Base(int num) : a(num) {}

    int a;
        int b = 1;	// error: 类的非静态成员，必须在构造函数中进行初始化
        static int c = 0;	// error: 类的静态成员，必须在类的外部进行初始化
        static const double d = 3.14;	// 类的静态常量成员，但不是整形或者枚举，无法通过编译
        // 说明: 如果使用 g++ 可能发现就地初始化 double 类型的静态常量是可以通过编译的，不过这实际是 GNU 对 C++ 的一个扩展，并不遵从 C++ 标准。

    static const char* const e = "i am luffy";
        // 类的静态常量成员，但不是整形或者枚举，无法通过编译
        const static int f = 0;
    };

### C++11标准下类成员初始化
