## [***命名空间***](../Class/11C%2B%2B/1day/1namespace.cpp)
### 为什么会出现命名空间这个概念?
- 把不同人写的变量集合(打包)成那个人的名字, 这样使用相同变量名时指定是哪个人的变量，这样就能避免同名变量冲突的问题
- 总的来说就是解决符号名称冲突
### 域作用符
- `::(variable)`**默认访问的是全局变量的值**
- `namespace::(variable)`**访问命名空间中变量的值**
### 命名空间中可以存放哪些内容
- 命名空间中可以定义变量, 也可以定义函数, 这些函数和变量只有该命名空间可以访问
### **命名空间注意点**
1. 若两个命名空间有相同的变量名或函数名, 则会出错

        namespace name1 {
            int a = 10;

            void show() {
                printf("Hello world\n");
            }
        }
        namespace name2 {
            void show() {
                printf("Hello world2\n");
            }
        } 
        using namespace name1;
        using namesapce name2; // error
2. 局部引用命名空间的变量
3. 命名空间中可以嵌套一个命名空间
4. 命名空间的取别名方式
5. **匿名命名空间**
---
## [***函数***](../Class/11C%2B%2B/1day/4functions.cpp)
---
## [***引用***](../Class/11C%2B%2B/1day/6cite.cpp)
---
## ***函数重载***
---
## ***类成员初始化方式***
### [1. 初始化列表](../Class/11C%2B%2B/2day/2project/Circle.cpp)

1. C++98标准下:

        struct Base
        {
            Base() : a(250) {}
            Base(int num) : a(num) {}

        int a;
            int b = 1;	// error: 类的非静态成员，必须在构造函数中进行初始化
            static int c = 0;	// error: 类的静态成员，必须在类的外部进行初始化
            static const double d = 3.14;	// 类的静态常量成员，但不是整形或者枚举，无法通过编译
            // 说明: 如果使用 g++ 可能发现就地初始化 double 类型的静态常量是可以通过编译的，不过这实际是 GNU 对 C++ 的一个扩展，并不遵从 C++ 标准。

        static const char* const e = "i am luffy";
            // 类的静态常量成员，但不是整形或者枚举，无法通过编译
            const static int f = 0;
        };
2.  C++11标准下类成员初始化
---
## ***C++11特性***
1. **列表初始化**
    - 统一初始化的语法, 统一使用`{}`
    - 适用于类的
        1. 变量
        2. 数组
        3. STL容器
        4. 类的构造函数
    - 示例

            int     *a = new int   { 3 };
            double   b = double    {12.12};
            int   *arr = new int[] {1,2,3};
2. **nullptr常量**
    - **当需要使用NULL时养成直接使用nullptr的习惯**
    - 用途: 代替NULL
    - 传统C/C++会把NULL和0视为同一个东西
3. **类型推断**
4. **lambda表达式(又称匿名函数)**
    1. 语法

            [capture list] (parameters) mutable throw() -> return-type (statement)
                捕获列表      参数列表  可变规则  异常说明     返回类型     函数体
                                                            (一般可忽略)
    2. 各参数解释
        1.  捕获列表
            1. 捕获列表能**捕捉上下文变量**供Lambda使用
            2. **多个参数用逗号隔开**, 不可重复捕获变量
            3. `[]`空着不填充表示不捕获变量
            4. `[val]/[&val]` 表示值传递/引用传递捕获变量val

                    int num = 100;
                    auto function = ([num]{
                        std::cout << num << std::endl;
                    }
                    );

                    function();
            5. `[=]`表示**值传递方式**捕获父作用域中的**所有变量(包括this)**

                    int index = 1;
                    int num   = 100;
                    auto function = ([=]{
                        std::cout << "index: " << index << ","
                                  << "num: "   << num   << std::endl;
                        }
                    );
                    function();
            6. `[&]`表示**引用传递方式**捕获作用域中的**所有变量(包括this)**
            7. `[this]`表示值传递的方式捕获当前的this指针

                    #include <iostream>
                    using namespace std;

                    class Lambda
                    {
                    public:
                        void sayHello() {
                            cout << "Hello " << endl;
                        };

                        void lambda() {
                            auto function = [this] {
                                this->sayHello();
                            };
                            function;
                        }
                    };
        2. **参数列表: 与普通函数参数列表一致, 如果不需要传参, 可连同`()`一起省略**
            - 也就是说参数列表中的内容是为`mutable`中的内容提供参数
        3. **可变规则: 默认情况下Lambda函数为const函数, 添加`mutable`修饰符后可取消这一特**  
        **性, 但必须填写参数列表, 无参时必须添加()**
            - 也就是说能改变捕获到的参数的值

                int main()
                {
                    int m = 0;
                    int n = 0;
                    [&, n] (int a) mutable (m = ++n + a; )(4);
                    cout << m << n << endl;
                    ----------------------
                    m = 5, n = 0;
                }
        4. 异常说明: 用于Lambda函数抛出异常
        5. 返回类型: 返回值不明确或不需要返回值的情况下可连同`->`一起省略  
        让编译器自动推导返回值类型
    3. **原理: 编译器会把一个Lambda表达式生成一个匿名类的匿名对象,**  
    **并在类中重载函数调用运算符, 实现了一个`operator[]`方法**

            auto print = []{cout << "Hello " << endl};
            
            // 以下写法被成为仿函数
            class  print_class
            {
            public:
                void operator()(void) const
                {
                    cout << "Hello" << endl;
                }
            };
            auto print = print_class();
5. **范围for循环**
    1.  基本语法

            想要读取数据: for (auto x:range)           拷贝了一份源数据, 可修改不会影响源数据
            想要修改元素: for (auto && x:range)        可以修改range的元素
            想要只读元素: for (const auto && x:range)  只读, 不可修改
        - `range`可以为**数组**, **字符串**和**容器**
    2. 示例

            // 1. 该案例与下面的案例中auto都可以替换为int
            int a[5] = {1,2,3,4,5};
            for (auto i:a) {
                cout << i << endl;
            }
            // 2.
            vector<int> vArr;
            vArr.push_back(10);
            vArr.push_back(20);
            vArr.push_back(30);
            vArr.push_back(40);
            vArr.push_back(50);

            for(auto i : vArr) {
                cout << i << endl;
            }
6. 别名using 
    - `using INT = int <==> typedef int INT`
7. 右值引用

        int main()
        {
            int &t = a;         // a为左值, 所以可以赋给左值引用
            // int &t1 = 3;     // 错误, 3为一个临时值, 为右值, 不能赋给左值引用
            // int &&t = a;     // 错误, a为左值, 不能赋给右值引用
            int &&t    = 3;     // 可以
            int &&t    = -a;    // 可以
            // int &t  = -a;    // 不可以
            // int &&t1= t;     // 不可以, t本身是左值
        }
---
## [***Template模板***](../Class/11C%2B%2B/6day/1template.cpp)
- [template顺序表](../Class/11C%2B%2B/6day/3temp_seqlist_teach2.cpp)
---
## ***STL容器(注意: 使用容器时需要包含头文件)***
1. [vector向量](../Class/11C%2B%2B/6day/4vector.cpp)
2. [列表](../Class/11C%2B%2B/6day/5list.cpp)
---
## ***new和cite***
1. new
    1. 不要使用delete来释放不是new分配的内存。
    2. 不要使用delete释放同一个内存块两次。
    3. 如果使用new\[\]为数组分配内存，则应使用delete\[\]来释放。
    4. 如果使用new\[\]为一个实体分配内存，则应使用delete（没有方括号）来释放。
    5. 对空指针应用delete是安全的。
2. cite
---
## ***C++强制类型转换***
1. `const_cast` 常量转换
    - 用途
        1. 将常量指针或引用转化为非常量指针或引用，且任然指向原来的对象
        2. 去除原有类型的const和volatile特效
    - 语法
        - `const_cast<new_type> (expression)`

                int arr[4] = {1,2,3,4};

                const int *c_ptr = arr;
                // c_ptr[1] = 233;   不允许

                int *ptr = const_cast<int *>(c_ptr); // 通过去常量
                c_ptr[1] = 233;      允许
2. `static_cast` 静态转换(QT槽函数)
    - 用途
        1. 类似于C语言的强转, 但不能实现普通指针数据(空指针除外)的强制转换
        2. 基本数据类型转换
        3. 无继承关系的自定义类型不可转换(**不支持不同类间的交叉转换**)
        4. 可以对普通数据的`const`转换为`non_const`, 但**不能对指针或引用操作**
        5. 可以用于父类和子类的指针、引用转换
            - **基类指针转换成派生类指针是不安全的, 且不会报错**

                    const char ch1 = 'c';
                    // ch1 = 'a' error
                    char ch2 = static_cast<char>(ch1);
                    ch1 = 'a'; // ok

                    int num = static_cast<int>(ch2);
3. `dynamic_cast`
4. `reinterpret_cast`
---
## ***静态成员函数***
- 主要用于类访问其静态成员变量, 通过`<类名>::<函数名>`的方式访问
- 注意点:
    1. [修饰成员函数时, 不能访问非静态成员, 只能访问静态成员](#其他)
---
## ***虚函数与虚函数表,纯虚函数是什么***
1.
2. 注意点
    1. **构造函数不能设置为虚函数**
    2. **析构函数最好设置成虚函数**, 否则不会发生动态多态而导致只会调用基类的析构函数, 从而有可能造成内存泄漏 
    3. 如果要定义就在基类中函数最前面加上`virtual`关键字
---
## ***STL容器与迭代器***
1. 使用迭代器遍历容器

        1. 
        vector<int> v;
        int a;
        //键盘输入数据，并放入容器中。这样不限制输入数据个数。
        while(cin >> a){
            v.push_back(a);
        }
        // 声明迭代器指针，指向容器开头位置
        vector<int>::iterator iter = v.begin();
        //正向遍历并输出元素
        while(iter != v.end()){
            cout << *iter << " ";
            iter++;
        }

        2.
        vector<int> vc(5);
        for(int i=0; i<5; i++){
            cin >> vc[i];
        }
        vector<int>::iterator  iter;
        for(iter=vc.begin(); iter!=vc.end(); iter++){
            cout << *iter << " ";
        }
        cout << endl;
        vector<int>::reverse_iterator riter;
        for(riter=vc.rbegin(); riter!=vc.rend(); riter++){
            cout << *riter << " ";
        }
---
## ***继承***
1. **公有继承(public)**：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，  
*基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。*
2. **保护继承(protected)**：当一个类派生自保护基类时，*基类的公有和保护成员将成为派生类的保护成员*。
3. **私有继承(private)**：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。
4. **菱形继承问题?**
---
## [***UML类图绘制***](../../../resource/3.UML%E7%B1%BB%E5%9B%BE%E5%9B%BE%E7%A4%BA/1.UML%E7%B1%BB%E5%9B%BE%E7%A4%BA%E4%BE%8B.png)
1. [类表示方法及接口表示方法](../../../resource/3.UML%E7%B1%BB%E5%9B%BE%E5%9B%BE%E7%A4%BA/2.%E7%B1%BB%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95.png)
2. [实现接口表示方法](../../../resource/3.UML%E7%B1%BB%E5%9B%BE%E5%9B%BE%E7%A4%BA/3.%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95.png)
    - 虚线加上空心三角形
3. [关联关系表示方式](../../../resource/3.UML%E7%B1%BB%E5%9B%BE%E5%9B%BE%E7%A4%BA/4.%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F.png)
    - 实心箭头
4. [聚合关系表示方式](../../../resource/3.UML%E7%B1%BB%E5%9B%BE%E5%9B%BE%E7%A4%BA/5.%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95.png)
    - 空心菱形加实心箭头
5. [合成关系表示方式](../../../resource/3.UML%E7%B1%BB%E5%9B%BE%E5%9B%BE%E7%A4%BA/6.%E5%90%88%E6%88%90%E5%85%B3%E7%B3%BB.png)
    - 实心菱形加实心箭头
6. [依赖关系](../../../resource/3.UML%E7%B1%BB%E5%9B%BE%E5%9B%BE%E7%A4%BA/7.%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png)
    - 虚线双向箭头
7. 继承关系
    - 空心三角形加上实心箭头
---
## ***其他***
1. static
    - 修饰成员函数时, 不能访问非静态成员, 只能访问静态成员

        class A
        {
            fun1();
            static fun2()
            {
                func1(); // 无法调用
            }
        }
2. 你new多少个对象你就得delete多少个对象

        A *p = new A[100]; 说明new了100个对象
        所以得delete100次

3. &a不能作为左值, 因为这里的&不是引用, 而地址是一个确定的值, 不能作为左值

4. 如何判断两个对象是否为同一个对象?
    - 判断两个对象的地址是否相等即可

5. 运算符重载:

        1. obj.100 // 成员访问运算符不能重载, 这个要是重载了就乱套了
        2. !obj
        3. obj++
        4. obj,100


6. 函数重载与覆盖隐藏的区别
    - 覆盖隐藏是基于**不同类** 
    - 函数重载属于**同一个类**

7. 动态多态与静态多态
    - 动态多态: 在**运行**的时候**自动确定**被调用的函数
    - 静态多态: 在编译的时候确定被调用的函数

8. 抽象类的派生类也是抽象类
    - 抽象类概念: 里面含有纯虚函数的类
    - 纯虚函数概念: virtual 函数名=0; 只在类中定义而不做实现

9. **构造函数不能设置为虚函数, 而且析构函数最好设置成虚函数**, 否则不会发生动态多态而导致只会调用基类的析构函数, 从而有可能造成内存泄漏

10. 关于构造函数定义格式的说明，具体如下。
    1. 构造函数名必须与类名相同。
    2. 构造函数名的前面不需要设置返回值类型。
    3. 构造函数中无返回值，不能使用return返回。
    4. 构造函数的成员权限控制符一般设置为public。

11. 什么是`动态联编`什么是`静态联编`
    1. 静态联编
        - 数组在编译前就固定了大小
    2. 动态联编
        - 数组在使用时动态分配内存大小

                int array[] = new int [10];
                delete [] array;
12. 面向对象的思维
    1. 使程序(对比活字印刷)
        1. 可维护
        2. 可复用
        3. 可扩展
        4. 灵活性好
    2. 降低程序耦合度, 不同功能封装不同的类