## [***命名空间***](../Class/11C%2B%2B/1day/1namespace.cpp)
### 为什么会出现命名空间这个概念?
- 把不同人写的变量集合(打包)成那个人的名字, 这样使用相同变量名时指定是哪个人的变量，这样就能避免同名变量冲突的问题
- 总的来说就是解决符号名称冲突
### 域作用符
- `::(variable)`**默认访问的是全局变量的值**
- `namespace::(variable)`**访问命名空间中变量的值**
### 命名空间中可以存放哪些内容
- 命名空间中可以定义变量, 也可以定义函数, 这些函数和变量只有该命名空间可以访问
### **命名空间注意点**
1. 若两个命名空间有相同的变量名或函数名, 则会出错

        namespace name1 {
            int a = 10;

            void show() {
                printf("Hello world\n");
            }
        }
        namespace name2 {
            void show() {
                printf("Hello world2\n");
            }
        } 
        using namespace name1;
        using namesapce name2; // error
2. 局部引用命名空间的变量
3. 命名空间中可以嵌套一个命名空间
4. 命名空间的取别名方式
5. **匿名命名空间**
---
## [***函数***](../Class/11C%2B%2B/1day/4functions.cpp)
---
## [***引用***](../Class/11C%2B%2B/1day/6cite.cpp)
---
## ***函数重载***
---
## ***类成员初始化方式***
### [1. 初始化列表](../Class/11C%2B%2B/2day/2project/Circle.cpp)

1. C++98标准下:

        struct Base
        {
            Base() : a(250) {}
            Base(int num) : a(num) {}

        int a;
            int b = 1;	// error: 类的非静态成员，必须在构造函数中进行初始化
            static int c = 0;	// error: 类的静态成员，必须在类的外部进行初始化
            static const double d = 3.14;	// 类的静态常量成员，但不是整形或者枚举，无法通过编译
            // 说明: 如果使用 g++ 可能发现就地初始化 double 类型的静态常量是可以通过编译的，不过这实际是 GNU 对 C++ 的一个扩展，并不遵从 C++ 标准。

        static const char* const e = "i am luffy";
            // 类的静态常量成员，但不是整形或者枚举，无法通过编译
            const static int f = 0;
        };
2.  C++11标准下类成员初始化
---
## ***C++11特性***
1. **列表初始化**
    - 统一初始化的语法, 统一使用`{}`
    - 适用于类的
        1. 变量
        2. 数组
        3. STL容器
        4. 类的构造函数
    - 示例

            int     *a = new int   { 3 };
            double   b = double    {12.12};
            int   *arr = new int[] {1,2,3};
2. **nullptr常量**
    - **当需要使用NULL时养成直接使用nullptr的习惯**
    - 用途: 代替NULL
    - 传统C/C++会把NULL和0视为同一个东西
3. **类型推断**
4. **lambda表达式(又称匿名函数)**
    1. 语法

            [capture list] (parameters) mutable throw() -> return-type (statement)
                捕获列表      参数列表  可变规则  异常说明     返回类型     函数体
                                                            (一般可忽略)
    2. 各参数解释
        1.  捕获列表
            1. 捕获列表能**捕捉上下文变量**供Lambda使用
            2. **多个参数用逗号隔开**, 不可重复捕获变量
            3. `[]`空着不填充表示不捕获变量
            4. `[val]/[&val]` 表示值传递/引用传递捕获变量val

                    int num = 100;
                    auto function = ([num]{
                        std::cout << num << std::endl;
                    }
                    );

                    function();
            5. `[=]`表示**值传递方式**捕获父作用域中的**所有变量(包括this)**

                    int index = 1;
                    int num   = 100;
                    auto function = ([=]{
                        std::cout << "index: " << index << ","
                                  << "num: "   << num   << std::endl;
                        }
                    );
                    function();
            6. `[&]`表示**引用传递方式**捕获作用域中的**所有变量(包括this)**
            7. `[this]`表示值传递的方式捕获当前的this指针

                    #include <iostream>
                    using namespace std;

                    class Lambda
                    {
                    public:
                        void sayHello() {
                            cout << "Hello " << endl;
                        };

                        void lambda() {
                            auto function = [this] {
                                this->sayHello();
                            };
                            function;
                        }
                    };
        2. **参数列表: 与普通函数参数列表一致, 如果不需要传参, 可连同`()`一起省略**
            - 也就是说参数列表中的内容是为`mutable`中的内容提供参数
        3. **可变规则: 默认情况下Lambda函数为const函数, 添加`mutable`修饰符后可取消这一特**  
        **性, 但必须填写参数列表, 无参时必须添加()**
            - 也就是说能改变捕获到的参数的值

                int main()
                {
                    int m = 0;
                    int n = 0;
                    [&, n] (int a) mutable (m = ++n + a; )(4);
                    cout << m << n << endl;
                    ----------------------
                    m = 5, n = 0;
                }
        4. 异常说明: 用于Lambda函数抛出异常
        5. 返回类型: 返回值不明确或不需要返回值的情况下可连同`->`一起省略  
        让编译器自动推导返回值类型
    3. **原理: 编译器会把一个Lambda表达式生成一个匿名类的匿名对象,**  
    **并在类中重载函数调用运算符, 实现了一个`operator[]`方法**

            auto print = []{cout << "Hello " << endl};
            
            // 以下写法被成为仿函数
            class  print_class
            {
            public:
                void operator()(void) const
                {
                    cout << "Hello" << endl;
                }
            };
            auto print = print_class();
5. **范围for循环**
    1.  基本语法

            想要读取数据: for (auto x:range)           拷贝了一份源数据, 可修改不会影响源数据
            想要修改元素: for (auto && x:range)        可以修改range的元素
            想要只读元素: for (const auto && x:range)  只读, 不可修改
        - `range`可以为**数组**, **字符串**和**容器**
    2. 示例

            // 1. 该案例与下面的案例中auto都可以替换为int
            int a[5] = {1,2,3,4,5};
            for (auto i:a) {
                cout << i << endl;
            }
            // 2.
            vector<int> vArr;
            vArr.push_back(10);
            vArr.push_back(20);
            vArr.push_back(30);
            vArr.push_back(40);
            vArr.push_back(50);

            for(auto i : vArr) {
                cout << i << endl;
            }
6. 别名using 
    - `using INT = int <==> typedef int INT`
7. 右值引用

        int main()
        {
            int &t = a;         // a为左值, 所以可以赋给左值引用
            // int &t1 = 3;     // 错误, 3为一个临时值, 为右值, 不能赋给左值引用
            // int &&t = a;     // 错误, a为左值, 不能赋给右值引用
            int &&t    = 3;     // 可以
            int &&t    = -a;    // 可以
            // int &t  = -a;    // 不可以
            // int &&t1= t;     // 不可以, t本身是左值
        }
---
## [***Template模板***](../Class/11C%2B%2B/6day/1template.cpp)
- [template顺序表](../Class/11C%2B%2B/6day/3temp_seqlist_teach2.cpp)
---
## ***STL容器(注意: 使用容器时需要包含头文件)***
1. [vector向量](../Class/11C%2B%2B/6day/4vector.cpp)
2. [列表](../Class/11C%2B%2B/6day/5list.cpp)
---
## ***new和cite***
1. new
    1. 不要使用delete来释放不是new分配的内存。
    2. 不要使用delete释放同一个内存块两次。
    3. 如果使用new\[\]为数组分配内存，则应使用delete\[\]来释放。
    4. 如果使用new\[\]为一个实体分配内存，则应使用delete（没有方括号）来释放。
    5. 对空指针应用delete是安全的。
2. cite
---
## ***C++强制类型转换***
1. `const_cast` 常量转换
    - 用途
        1. 将常量指针或引用转化为非常量指针或引用，且任然指向原来的对象
        2. 去除原有类型的const和volatile特效
    - 语法
        - `const_cast<new_type> (expression)`

                int arr[4] = {1,2,3,4};

                const int *c_ptr = arr;
                // c_ptr[1] = 233;   不允许

                int *ptr = const_cast<int *>(c_ptr); // 通过去常量
                c_ptr[1] = 233;      允许
2. `static_cast` 静态转换(QT槽函数)
    - 用途
        1. 类似于C语言的强转, 但不能实现普通指针数据(空指针除外)的强制转换
        2. 基本数据类型转换
        3. 无继承关系的自定义类型不可转换(**不支持不同类间的交叉转换**)
        4. 可以对普通数据的`const`转换为`non_const`, 但**不能对指针或引用操作**
        5. 可以用于父类和子类的指针、引用转换
            - **基类指针转换成派生类指针是不安全的, 且不会报错**

                    const char ch1 = 'c';
                    // ch1 = 'a' error
                    char ch2 = static_cast<char>(ch1);
                    ch1 = 'a'; // ok

                    int num = static_cast<int>(ch2);
3. `dynamic_cast`
4. `reinterpret_cast`
---
## ***静态成员函数***
- 主要用于类访问其静态成员变量, 通过`<类名>::<函数名>`的方式访问
- 注意点:
    1. [修饰成员函数时, 不能访问非静态成员, 只能访问静态成员](#其他)
---
## ***虚函数与虚函数表,纯虚函数是什么***
1.
2. 注意点
    1. **构造函数不能设置为虚函数**
    2. **析构函数最好设置成虚函数**, 否则不会发生动态多态而导致只会调用基类的析构函数, 从而有可能造成内存泄漏 
    3. 如果要定义就在基类中函数最前面加上`virtual`关键字
---
## ***STL容器与迭代器***
1. 使用迭代器遍历容器

        1. 
        vector<int> v;
        int a;
        //键盘输入数据，并放入容器中。这样不限制输入数据个数。
        while(cin >> a){
            v.push_back(a);
        }
        // 声明迭代器指针，指向容器开头位置
        vector<int>::iterator iter = v.begin();
        //正向遍历并输出元素
        while(iter != v.end()){
            cout << *iter << " ";
            iter++;
        }

        2.
        vector<int> vc(5);
        for(int i=0; i<5; i++){
            cin >> vc[i];
        }
        vector<int>::iterator  iter;
        for(iter=vc.begin(); iter!=vc.end(); iter++){
            cout << *iter << " ";
        }
        cout << endl;
        vector<int>::reverse_iterator riter;
        for(riter=vc.rbegin(); riter!=vc.rend(); riter++){
            cout << *riter << " ";
        }
---
## ***继承***
1. **公有继承(public)**：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，  
**基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。**
2. **保护继承(protected)**：当一个类派生自保护基类时，**基类的公有和保护成员将成为派生类的保护成员**
3. **私有继承(private)**：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。
4. **菱形继承问题?**
5. 虚继承
---
## ***构造函数***
1. 拷贝构造函数
    - 把基于该类的对象作为构造函数的参数, 再构造一个跟其一模一样的对象

            class Complex{
            public:
                double real, imag;
                Complex(double r,double i){
                    real = r; imag = i;
                }
                Complex(const Complex & c){             // 拷贝构造函数
                    real = c.real; imag = c.imag;
                    cout<<"Copy Constructor called"<<endl ;
                }*
            };

            int main()
            {
                Complex a(3.14, 3.15);
                Complex b(a);
            }
2. **什么时候会调用拷贝构造函数?**
    1. 主动创建对象时，用一个对象去初始化另一个对象的时候`eg. BASE b1 = b2`
    2. 一个对象以值传递的形式传入函数体
    3. 一个对象以值的形式从函数返回

            下列程序输出的 * 个数是（） answer: 4
            class Point {
            public:
                Point(int xx = 0, int yy = 0) {
                    X = xx;
                    Y = yy;
                }
                Point(Point &p) {
                    X = p.X;
                    Y = p.Y;
                    cout << "*";
                }
            private:
                int X, Y;
            };
            class Line {
            public:
                Line(Point xp1, Point xp2) : p1(xp1), p2(xp2) {}   
            /*
            Line (Point xp1, Point xp2):p1(xp1),p2(xp2)中使用的是传值
            myp1和myp2传值给xp1，xp2时使用了两次复制构造函数.
            p1(xp1),p2(xp2)又使用了两次，因此一共是四次。
            */
            private:
                Point p1, p2;
            };
3. 其他
    - 当没有构造函数时, 会默认存在一个构造函数*
    - **构造函数与析构函数无返回类型**
    - 类指针的声明，是不会调用构造函数的, 但是指向一个类实例（new）就会调用构造函数,  
---
## [***C++中的static关键字***](../Class/11C++/3day/3static.cpp)
1. 修饰成员变量
    1. 语法
        1. 在 class 中进行声明: `static <类型修饰符> <变量名>`
        2. 在 class 外进行初始化: `<类型修饰符><类名>::<变量名> = <初始化值>`
    2. 特点
        1. **static 修饰的成员变量属于类不属于具体的对象（只属于类）**
        2. static 成员变量的内存在程序开始运行时分配，程序运行结束时释放内存
        3. static 成员变量对于所有的对象是共享的，并在对象创建之前就已经产生了
        4. **静态成员使用前必须初始化，否则会在linker(链接)步骤时出错**
        5. 在成员函数中可以正常访问静态成员变量
2. **修饰成员函数**
    1. 语法
        - `static <函数返回值><函数名>(参数列表)`
    2. 特点
        1. 可以被对象直接使用
        2. **可以通过类名直接访问**
        3. **不能使用 this 指针，与类关联,不与对象关联,在调用静态函数时**，  
        **可以在没有对象时调用**
        4. **不能访问非静态成员,只能访问静态成员**
3. 何时使用static
    - **一切不需要实例化（创建对象）就可以有确定行为方式的函数都应该设计成静态的。**
4. 注意点
    1. C++中静态变量（无论是全局还是局部变量）的初始化在任何代码之前。**因此静态变量的初始化早于构造函数说法错误**
    2. static类变量又叫静态成员变量，**它不需要创建对象就可以已经在内存中存在了**
    3. 在创建实例对象的时候，内存中会为每一个实例对象的每一个非静态成员变量开辟一段内存空间，用来存储这个对象所有的非静态成员变量值
    4. static类变量是所有对象共有，其中一个对象将它值改变，其他对象得到的就是改变后的结果
    5. 实例变量则属对象私有，某一个对象将其值改变，不影响其他对象
---
## ***const***
1. const成员变量
    - const成员变量只能在初始化列表中初始化
2. const成员函数
    - const成员函数也可以与同名非const成员函数构成函数重载
---
## [***UML类图绘制***](../../../resource/3.UML%E7%B1%BB%E5%9B%BE%E5%9B%BE%E7%A4%BA/1.UML%E7%B1%BB%E5%9B%BE%E7%A4%BA%E4%BE%8B.png)
1. [类表示方法及接口表示方法](../../../resource/3.UML%E7%B1%BB%E5%9B%BE%E5%9B%BE%E7%A4%BA/2.%E7%B1%BB%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95.png)
2. [实现接口表示方法](../../../resource/3.UML%E7%B1%BB%E5%9B%BE%E5%9B%BE%E7%A4%BA/3.%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95.png)
    - 虚线加上空心三角形
3. [关联关系表示方式](../../../resource/3.UML%E7%B1%BB%E5%9B%BE%E5%9B%BE%E7%A4%BA/4.%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F.png)
    - 实心箭头
4. [聚合关系表示方式](../../../resource/3.UML%E7%B1%BB%E5%9B%BE%E5%9B%BE%E7%A4%BA/5.%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95.png)
    - 空心菱形加实心箭头
5. [合成关系表示方式](../../../resource/3.UML%E7%B1%BB%E5%9B%BE%E5%9B%BE%E7%A4%BA/6.%E5%90%88%E6%88%90%E5%85%B3%E7%B3%BB.png)
    - 实心菱形加实心箭头
6. [依赖关系](../../../resource/3.UML%E7%B1%BB%E5%9B%BE%E5%9B%BE%E7%A4%BA/7.%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png)
    - 虚线双向箭头
7. 继承关系
    - 空心三角形加上实心箭头
---
## ***其他***
1. static
    - 修饰成员函数时, 不能访问非静态成员, 只能访问静态成员

        class A
        {
            fun1();
            static fun2()
            {
                func1(); // 无法调用
            }
        }
2. 你new多少个对象你就得delete多少个对象

        A *p = new A[100]; 说明new了100个对象
        所以得delete100次

3. &a不能作为左值, 因为这里的&不是引用, 而地址是一个确定的值, 不能作为左值

4. 如何判断两个对象是否为同一个对象?
    - 判断两个对象的地址是否相等即可

5. 运算符重载:

        1. obj.100 // 成员访问运算符不能重载, 这个要是重载了就乱套了
        2. !obj
        3. obj++
        4. obj,100


6. 函数重载与覆盖隐藏的区别
    - 覆盖隐藏是基于**不同类** 
    - 函数重载属于**同一个类**

7. 动态多态与静态多态
    - 动态多态: 在**运行**的时候**自动确定**被调用的函数
    - 静态多态: 在编译的时候确定被调用的函数

8. 抽象类的派生类也是抽象类
    - 抽象类概念: 里面含有纯虚函数的类
    - 纯虚函数概念: virtual 函数名=0; 只在类中定义而不做实现

9. **构造函数不能设置为虚函数, 而且析构函数最好设置成虚函数**, 否则不会发生动态多态而导致只会调用基类的析构函数, 从而有可能造成内存泄漏

10. 关于构造函数定义格式的说明，具体如下。
    1. 构造函数名必须与类名相同。
    2. 构造函数名的前面不需要设置返回值类型。
    3. 构造函数中无返回值，不能使用return返回。
    4. 构造函数的成员权限控制符一般设置为public。

11. 什么是`动态联编`什么是`静态联编`
    1. 静态联编
        - 数组在编译前就固定了大小
    2. 动态联编
        - 数组在使用时动态分配内存大小

                int array[] = new int [10];
                delete [] array;
12. 面向对象的思维
    1. 使程序(对比活字印刷)
        1. 可维护
        2. 可复用
        3. 可扩展
        4. 灵活性好
    2. 降低程序耦合度, 不同功能封装不同的类
13. **explicit隐式转换关键字**
    1. explicit关键字只能用来修饰类的构造函数，且最好只修饰只有一个参数的构造函数
    2. 被修饰的构造函数不能发生相应的隐式类型转换，只能以显示的方式进行类型转换

14. cout遇到'\0'时结束, 判断字符串长度时以'\0'为结束点, sizeof是计算字节大小, '\0'算作一个字符即一个字节, sizeof("hello\0world") = 12 字符串自带一个结束符。string通过.length判断字符串长度也是以'\0'为基准计算(不包含'\0'), **但是sizeof(string)的大小由编译器决定, 4, 12, 32都有可能**

        char str[] = "hello\0world";
        char str2[]= "helloworld";
        char str3[]= {'h', 'e', 'l', 'l', 'o'};

        
        string str4 = "hello\0world";
        string str5 = "helloworld";

        cout << "str1: " << str << " .size: " << sizeof(str) << endl;
        cout << "str2: " << str2 <<" .size: " << sizeof(str2) << endl;
        cout << "str3: " << str3 << " .size: " << sizeof(str3) << endl;

        cout << "str4: " << str4 << " .size: " << sizeof(str4) << " length: " << str4.length() << endl;
        cout << "str5: " << str5 << " .size: " << sizeof(str5) << " length: " << str5.length() << endl;
        out_put:------------------------------------
        str1: hello .size: 12
        str2: helloworld .size: 11
        str3: hello .size: 5
        str4: hello .size: 32 length: 5  ubuntu(16.04):32  windows_vscode: 24
        str5: helloworld .size: 32 length: 10
