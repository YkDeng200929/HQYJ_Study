# 进程线程

## 进程
### 进程的组成
#### 系统数据段
- 系统相关信息(命令行参数, 环境变量)
- 栈
- 堆(malloc)
#### 用户数据段
- bss
- data
#### 正文段
- rodata
- text

### 与程序组成的区别
#### 程序的组成
- bss
- data
- rodata
- text

### 进程的表示
#### PID: 进程ID号
#### PPID: 父进程ID
#### state: 进程的状态
- R: 运行态
- S: 可中断等待态
- D: 不可中断等待态
- T: 停止态
- Z: 僵尸态

### 进程相关命令
#### pstree: 以树形结构显示进程的信息
- `-p`: 该参数以显示进程 PID 号
#### ps -aux 显示进程的状态
#### ps -ef
#### kill: 给指定的 PID 进程发送信号
- kill -l: 显示不同信号对应的含义
- 9: 杀死
- 18: 继续运行
- 19: 暂停运行
#### bg: 将挂起的进程继续在**后台运行**
#### fg: 将挂起的进行继续在**前台运行**
#### jobs: 查看**当前终端下**的进程状态(是否有挂起的进程)

### 虚拟地址和物理地址
- MMU(Memery Management Union): 内存管理单元<br>通过内存管理单元实现映射
- 虚拟地址是物理地址在内存中的映射

### 创建子进程函数
#### `pid_t fork(void)`:<br>说明: 在当前进程中创建子进程<br>返回值: 成功的话给当前的父进程返回子进程的 PID 号, 失败返回 -1并置 errno
#### 一些关于子进程创建的说明
- 子进程创建的过程, 拷贝父进程的堆, 栈, rodata段, data段, bss段
- fork之后, 父子进程谁先执行是不确定的, 取决于系统的算法
- fork之后, 父子进程都是从 fork 的下一条语句开始执行
- fork之后, 父子进程都拥有独立的 4G 虚拟地址空间, 互相不影响
- **fork之后, 子进程会继承父进程打开的文件描述符集合, 共享文件标识符和文件的偏移量**
- **PID > 0 表示此时是父进程, PID == 0 表示此时是子进程**

### 获得PID的函数
- `pid_t getpid(void)`
- `pid_t getppid(void)`

### 常用退出函数
- `return`
- `void exit(int status)`库函数:<br>说明: status表示进程状态的标识, 0表示正常结束, 其他表示异常结束<br>**结束刷新缓冲区**
- `void _exit(int status)`系统调用:<br>说明: **不会刷新缓冲区**

### 回收僵尸进程
#### `pid_t wait(int *status)`:<br>说明: 回收僵尸态子进程, 如果没有僵尸态子进程则阻塞, 如果有子进程会立即返回<br>参数说明: <br>status: 指向的对象用来保存子进程退出时的状态<br>status == NULL: 表示忽略子进程退出时的状态<br> status != NULL: 表示保存子进程退出时的状态<br>返回值: 成功返回僵尸态子进程的PID,  失败返回-1;

### 守护进程
#### 守护进程的定义
1. 通常说的 daemon 进程, 就是 linux 的后台服务进程
2. 它通常独立于终端控制, 并且周期性的执行某种任务或等待处理某些发生的事件
3. 它通常在系统启动时开始运行, 在系统关闭时终止
4. 在linux系统中，由于在linux中，每个系统与用户进行交流的界面成为终端，<br>每一个从此终端开始运行的进程都会依附于这个终端，这个终端被称为这些进程的控制终端，<br>当控制终端被关闭的时候，相应的进程都会自动关闭。<br>但是守护进程却能突破这种限制，它脱离于终端并且在后台运行，<br>并且它脱离终端的目的是为了避免进程在运行的过程中的信息在任<br>何终端中显示并且进程也不会被任何终端所产生的终端信息所打断。
#### `ps axj` 查看守护进程
#### 守护进程的特点
1. 后台运行，独立于终端，完成一定的任务
2. 首先所谓的后台运行过程是一般是在图形界面或是终端不可见的
3. 而独立于终端是说它不和终端联系，运行之后一般不接受终端的输入也不向终端输出
4. 每一个守护进程的运行都是为了完成一定的任务而运行的，这些任务一般都是系统相关的任务
#### 创建守护进程的步骤
##### 1. 创建子进程, 父进程退出
- `fork()`
- `exit()`
##### 2. 在子进程中创建新的会话
- `setsid()`
##### 3. 改变进程的工作目录到"/"
- `chdir("/")`
##### 4. 重设文件掩码
- `umask(0)`
##### 5. 关掉不需要的文件描述符号
- `close()`

### 进程间的通信方式
#### 管道
- 有名管道
- 无名管道
#### 信号
#### 消息队列
#### 共享内存
#### 信号量
#### 套接字

## 线程

### **注意: 编译含线程函数的文件时需要加上 `-lpthread` 参数**
### 说明
1. 一个进程只有一个主线程, 就是main函数, 主线程可以创建一个或多个对等线程(peer thread), 从创建这个时间点开始, 这些线程就是开始并发执行
2. 主线程总是第一个运行的线程, 对等线程的执行顺序不确定

### 问题
#### **多线程哪些进程的资源共享, 哪些资源独有?**
##### 共享资源
1. 全局变量
2. 进程中打开的文件描述符, 用户ID等
##### 私有资源
1. 线程ID(tid)
2. 系统相关的数据(函数运行环境, 局部变量, 私有栈)
#### 进程和线程的异同点
##### 相同点
1. 都参与系统的统一调度
2. 都有自己的ID值
##### 不同点
1. 进程拥有独立的 4G 虚拟空间<br>而线程是共享内存的地址空间
2. 进程上下 文的切换资源消耗比较大, 而线程是在进程内部切换, 资源比较小

### 线程的创建
- `int pthread_create(pthread *thread, const pthread_attr_t *attr, void *(*start_rutine)(void *), void *arg)`<br>说明: 创建一个线程, 调用线程执行函数, 实现线程的创建<br>参数: <br>thread: tid<br>attr: 线程的属性(分离属性和结合属性),NULL表示默认属性(结合属性)<br>start_routine: 线程的执行函数, 采用回调方式执行线程函数<br>arg: 给线程函数传递的参数<br>返回值: **成功返回0**, 失败返回错误码, 但不一定会置errno(所以结合stderr, 使用fprintf打印)  

### 线程终止
#### `void pthread_exit(void *retval)`<br>说明: 结束当前线程的执行<br>参数:<br>retval: 给等待的线程带回一个返回值, 如果没有返回值, 写为NULL
#### 说明
1. 主线程中如果从main函数返回return或者是调用了exit()函数则退出当前进程, 此时所有的其他线程也将终止
2. 主线程如果调用了pthread_exit, 则仅仅是主线程结束, 进程不会结束, 所以其他线程也不会结束, 直到所有的线程都结束的时候, 进程才会结束

### 等待线程退出的函数
#### `int pthread_join(pthread_t thread, void **retval)`<br>说明: **阻塞**的方式等待指定的线程退出, 并且释放线程占用的资源<br>参数说明: <br>thread: 线程 tid<br>retval: 获得 pthread_exit 带回的地址值<br>返回值: 成功返回0, 失败返回错误码(stderr)
#### pthread_join 与 pthread_exit 的区别
1. pthread_join 一般是主线程来调用, 用于等待子线程退出, 因为是等待, 所以阻塞, 一般主线程会依次 join 所有的子线程
2. phtread_exit ***一般是子线程的调用, 用于结束当前线程***

### 创建分离式线程
#### `int pthread_detach(pthread_t thread)`**非阻塞**<br>说明: 该函数将线程标记为分离式线程<br>返回值: 成功返回0, 失败返回stderr错误码
#### 分离式线程的特点<br>**线程结束的时候, 系统自动回收资源, 就不需要 pthread_join 来回收系统资源了**

### 取消一个线程
#### `int pthread_cancel(pthread_t thread)`<br>说明: 取消一个线程的执行