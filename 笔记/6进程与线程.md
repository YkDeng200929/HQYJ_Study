# 进程线程

## 进程

### 进程的组成

#### 系统数据段

- 系统相关信息(命令行参数, 环境变量)
- 栈
- 堆(malloc)

#### 用户数据段

- bss
- data

#### 正文段

- rodata
- text

### 与程序组成的区别

#### 程序的组成

- bss
- data
- rodata
- text

### 进程的表示

#### PID: 进程ID号

#### PPID: 父进程ID

#### state: 进程的状态

- R: 运行态
- S: 可中断等待态
- D: 不可中断等待态
- T: 停止态
- Z: 僵尸态

### 进程相关命令

#### pstree: 以树形结构显示进程的信息

- `-p`: 该参数以显示进程 PID 号

#### ps -aux 显示进程的状态

#### ps -ef

#### kill: 给指定的 PID 进程发送信号

- kill -l: 显示不同信号对应的含义
- 9: 杀死
- 18: 继续运行
- 19: 暂停运行

#### bg: 将挂起的进程继续在**后台运行**

#### fg: 将挂起的进行继续在**前台运行**

#### jobs: 查看**当前终端下**的进程状态(是否有挂起的进程)

### 虚拟地址和物理地址

- MMU(Memery Management Union): 内存管理单元 `<br>`通过内存管理单元实现映射
- 虚拟地址是物理地址在内存中的映射

### 创建子进程函数

#### `pid_t fork(void)`

- 说明: 在当前进程中创建子进程
- 返回值: 成功的话给当前的父进程返回子进程的 PID 号, 失败返回 -1并置 errno

#### 一些关于子进程创建的说明

- 子进程创建的过程, 拷贝父进程的堆, 栈, rodata段, data段, bss段
- fork之后, 父子进程谁先执行是不确定的, 取决于系统的算法
- fork之后, 父子进程都是从 fork 的下一条语句开始执行
- fork之后, 父子进程都拥有独立的 4G 虚拟地址空间, 互相不影响
- **fork之后, 子进程会继承父进程打开的文件描述符集合, 共享文件标识符和文件的偏移量**
- **PID > 0 表示此时是父进程, PID == 0 表示此时是子进程**

### 获得PID的函数

#### `pid_t getpid(void)`

#### `pid_t getppid(void)`

### 常用退出函数

#### `return`

#### `void exit(int status)`库函数

- 说明: status表示进程状态的标识, 0表示正常结束, 其他表示异常结束
- **结束刷新缓冲区**

#### `void _exit(int status)`系统调用

- 说明: **不会刷新缓冲区**

### 回收僵尸进程

#### `pid_t wait(int *status)`

- 说明: 回收僵尸态子进程, 如果没有僵尸态子进程则阻塞, 如果有子进程会立即返回
- status: 指向的对象用来保存子进程退出时的状态
- status == NULL: 表示忽略子进程退出时的状态
- status != NULL: 表示保存子进程退出时的状态
- 返回值: 成功返回僵尸态子进程的PID, 失败返回-1;

### 守护进程

#### 守护进程的定义

1. 通常说的 daemon 进程, 就是 linux 的后台服务进程
2. 它通常独立于终端控制, 并且周期性的执行某种任务或等待处理某些发生的事件
3. 它通常在系统启动时开始运行, 在系统关闭时终止
4. 在linux系统中，由于在linux中，每个系统与用户进行交流的界面成为终端，`<br>`每一个从此终端开始运行的进程都会依附于这个终端，这个终端被称为这些进程的控制终端，`<br>`当控制终端被关闭的时候，相应的进程都会自动关闭。`<br>`但是守护进程却能突破这种限制，它脱离于终端并且在后台运行，`<br>`并且它脱离终端的目的是为了避免进程在运行的过程中的信息在任 `<br>`何终端中显示并且进程也不会被任何终端所产生的终端信息所打断。

#### `ps axj` 查看守护进程

#### 守护进程的特点

1. 后台运行，独立于终端，完成一定的任务
2. 首先所谓的后台运行过程是一般是在图形界面或是终端不可见的
3. 而独立于终端是说它不和终端联系，运行之后一般不接受终端的输入也不向终端输出
4. 每一个守护进程的运行都是为了完成一定的任务而运行的，这些任务一般都是系统相关的任务

#### 创建守护进程的步骤

##### 1. 创建子进程, 父进程退出

- `fork()`
- `exit()`

##### 2. 在子进程中创建新的会话

- `setsid()`

##### 3. 改变进程的工作目录到"/"

- `chdir("/")`

##### 4. 重设文件掩码

- `umask(0)`

##### 5. 关掉不需要的文件描述符号

- `close()`

### **进程间的通信方式(重要)**

#### 管道

##### 有名管道

###### 特点

1. 以FIFO的文件形式存在于文件系统中
2. 对管道及FIFO的读总是从开始处返回数据, 写则把数据添加到末尾
3. **不支持lseek等文件定位的操作**
4. 这玩意也就是说能在两个可执行文件(进程)中实现同时读写的功能(一个终端进程实现读, 另一个终端进程实现写)

###### 有名管道的创建

- `mkfifo(const char *pathname, mode_t mode)`
- pathname 是管道文件的创建路径, 若文件名存在则返回EEXIST错误, 成功执行返回0, 失败返回 -1 并置errno
- 错误处理

```
if (mkfifo(path, 0666) < 0 && errno != EEXIST)
```

- 例如

```
read.c
mkfifo(创建有名管道)
open(有名管道)
read(有名管道)

write.c
mkfifo(创建有名管道)
open(有名管道)
write(有名管道)

-->gcc read.c -o read && gcc write.c -o write.c
-->tty1: ./read tty2: ./write
```

##### 无名管道

###### 特点

1. 半双工的通信方式(两个进程同时进行, 但是读写只能单次进行其中一种)
2. 只能用于具有亲缘关系的进程(也就是只能在一个进程中创建子进程或孙子进程来实现, 也就是只能通过一个可执行文件实现)
3. 一个进程向管道中写的内容被管道另一端的进程读出, 写入的内容每次都添加在管道缓冲区的末尾, 并且每次都是从缓冲区的头部读出数据(也就是不需要用lseek类似的函数来重置偏移量)

###### 无名管道的创建

- `int pipe(int pipefd[2])`:pipefd[0]是读端的文件描述符, [1]是写端的文件描述符
- 所以不需要自己定义文件描述符
- 例如

```
int fd[2]
pip(fd);
fork()
pid > 0
{
    close(fd[0]);
    write(fd[1]);
}
pid == 0
{
    close(fd[1]);
    read(fd[0]);
}
```

#### 信号

#### 消息队列

#### 共享内存

#### 信号量

#### 套接字

## 线程

### **注意: 编译含线程函数的文件时需要加上 `-lpthread` 参数**

### 说明

1. 一个进程只有一个主线程, 就是main函数, 主线程可以创建一个或多个对等线程(peer thread), 从创建这个时间点开始, 这些线程就是开始并发执行
2. 主线程总是第一个运行的线程, 对等线程的执行顺序不确定

### 问题

#### **多线程哪些进程的资源共享, 哪些资源独有?**

##### 共享资源

1. 全局变量
2. 进程中打开的文件描述符, 用户ID等

##### 私有资源

1. 线程ID(tid)
2. 系统相关的数据(函数运行环境, 局部变量, 私有栈)

#### 进程和线程的异同点

##### 相同点

1. 都参与系统的统一调度
2. 都有自己的ID值

##### 不同点

1. 进程拥有独立的 4G 虚拟空间`<br>`**而线程是共享内存的地址空间**
2. 进程上下 文的切换资源消耗比较大, 而线程是在进程内部切换, 资源比较小

### 线程的创建

#### `int pthread_create(pthread *thread, const pthread_attr_t *attr, void *(*start_rutine)(void *), void *arg)`

- 说明: 创建一个线程, 调用线程执行函数, 实现线程的创建
- thread: tid
- attr: 线程的属性(分离属性和结合属性),NULL表示默认属性(结合属性)
- start_routine: 线程的执行函数, 采用回调方式执行线程函数
- arg: 给线程函数传递的参数
- 返回值: **成功返回0**, 失败返回错误码, 但不一定会置errno(所以结合stderr, 使用fprintf打印)

### 线程终止

#### `void pthread_exit(void *retval)`

- 说明: 结束当前线程的执行
- retval: 给等待的线程带回一个返回值, 如果没有返回值, 写为NULL

#### 说明

1. 主线程中如果从main函数返回return或者是调用了exit()函数则退出当前进程, 此时所有的其他线程也将终止
2. 主线程如果调用了pthread_exit, 则仅仅是主线程结束, 进程不会结束, 所以其他线程也不会结束, 直到所有的线程都结束的时候, 进程才会结束

### 等待线程退出的函数

#### `int pthread_join(pthread_t thread, void **retval)`

- 说明: **阻塞**的方式等待指定的线程退出, 并且释放线程占用的资源
- thread: 线程 tid
- retval: 获得 pthread_exit 带回的地址值
- 返回值: 成功返回0, 失败返回错误码(stderr)

#### pthread_join 与 pthread_exit 的区别

1. pthread_join 一般是主线程来调用, 用于等待子线程退出, 因为是等待, 所以阻塞, 一般主线程会依次 join 所有的子线程
2. phtread_exit ***一般是子线程的调用, 用于结束当前线程***

### 创建分离式线程

#### `int pthread_detach(pthread_t thread)`**非阻塞**

- 说明: 该函数将线程标记为分离式线程
- 返回值: 成功返回0, 失败返回stderr错误码

#### 分离式线程的特点

- **线程结束的时候, 系统自动回收资源, 就不需要 pthread_join 来回收系统资源了**

### 取消一个线程

#### `int pthread_cancel(pthread_t thread)`

- 说明: 取消一个线程的执行

### 线程间的同步与互斥

#### 同步: 相互之间按照一定顺序完成任务

- `sem_t <变量>`: 定义信号量
- `sem_init(sem_t, pshared, value)`: pshared 一般默认为0, 你想让哪个信号先发出哪个的value就填1
- `sem_wait`: 等待信号量0为阻塞, 1则通行
- `sem_post`: 发送信号量

#### 互斥: 一个线程访问资源的时候不允许其他线程访问

- `pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER`
- `pthread_mutex_lock`: 获得互斥锁**获得互斥锁则立即返回, 否则阻塞直到获得互斥锁**
- `pthread_mutex_unlock`: 释放互斥锁
- `pthread_mutex_destroy`: 销毁互斥锁

#### 条件变量

- 定义: 条件变量是利用线程间共享的全局变量进行同步通信的一种机制
- `pthread_cont_t cond = PTHREAD_COND_INITIALIZER`
- `pthread_cond_wait`等待条件变量, 条件变量不满足时阻塞当前进程
- `pthread_cond_signal`唤醒**至少一个**等待线程
- `pthread_cond_broadcast`唤醒所有的等待线程
- `pthread_cond_destroy` 摧毁条件变量
