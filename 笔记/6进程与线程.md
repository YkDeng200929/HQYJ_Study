# 进程线程

## 1. 规则
### 1.1 进程与线程的关系
### 1.2 进程与线程的定义
### 1.3 线程运行的规则
1. 编译含线程函数的文件时需要加上 `-lpthread` 参数
2. 一个进程只有一个主线程, 就是 main函数, 主线程可以创建一个或多个对等线程(peer thread), 从创建这个时间点开始, 这些线程就是开始并发执行
3. 主线程总是第一个运行的线程, 对等线程的执行顺序不确定
### 1.4 线程对于资源的使用
1. 共享资源
    1. 全局变量
    2. 进程中打开的文件描述符, 用户ID
2. 私有资源
    1. 线程ID
    2. 系统相关的函数(函数运行环境, 全局变量, 私有栈)

## 2. [进程](./个人总结/文件IO_进程线程总结/3进程总结.c)

### 2.1 概念
#### 2.1.1 进程的组成
1. 系统数据段
    - 系统相关信息(命令行参数, 环境变量)
    - 栈
    - 堆(malloc)
2. 用户数据段
    - bss
    - data
3. 正文段
    - rodata
    - text
#### 2.1.2 进程与程序的区别
1. 与[进程的组成](#211-进程的组成)对比
    1. bss
    2. data
    3. rodata
    4. text
#### 2.1.3 进程的表示方式
1. PID: 进程的标志
2. PPID: 父进程的标志
3. state: 进程运行的状态
#### 2.1.4 进程的状态
#### 2.1.5 关于子进程与父进程的一些事
1. 子进程会拷贝一份父进程的资源使用(所以当子进程中改变全局或局部变量时不会改变父进程的值)
2. fork之后, 父子进程谁先执行由系统IO调度决定
3. 父子进程都是从fork的下一条语句开始执行
4. fork之后, 父子进程都拥有独立的4G虚拟地址空间, 互相不影响
5. **fork之后, 子进程会继承父进程打开的文件描述符集合, 共享文件标识符和文件的偏移量**
6. **PID > 0 时表示此时是父进程在运行, PID = 0 时表示此时是子进程在运行**
#### 2.1.6 守护进程(daemon)
1. 特点
    1. 后台运行, 独立于终端, 完成一定的任务
    2. 图形界面或终端不可见
    3. 独立于终端运行不是说它不和终端练习, 而是说运行之后一般不接受终端的输入也不向终端输出
    4. 每一个守护进程的运行都是为了完成一定的任务而运行的, 这些任务一般都是系统相关的任务
2. 查看守护进程的命令: `ps axj` **TPGID 为 -1的为守护进程**
3. 创建守护进程的步骤
    1. 创建子进程, 父进程退出
        - `fork`
        - `exit`
    2. 在子进程中创建新的会话
        - `setsid`
    3. 改变进程的工作目录到"/"
        - `chdir`
    4. 重设文件掩码
        - `umask`
    5. 关掉不需要的文件描述符
        - `close`
#### 2.1.7 **进程间的通信方式**
1. [信号](./7进程间通信.md#信号)
2. 管道
    - 有名管道 特点
    - 无名管道 特点
3. IPC(internal process communication)
    - [共享内存](./个人总结/IPC通信总结/1共享内存/2shm1.c)
    - [消息队列](./个人总结/IPC通信总结/2消息队列/1send.c)
    - [信号灯](/Class/8进程间的通信/my_day6/3IPC对象/3teach_信号灯/sem.c)
4. 套接字
#### 2.1.8 进程相关的linux命令
1. `pstree -p`: 以树形结构显示进程信息(显示 PID号)
2. `ps -aux`: 显示当前进程的运行态
3. `ps -ef | head -1`: 显示有关进程的名词
4. `kill`: 给进程发信号**(不是杀死进程)**
    - `kill -l` 查信号
    - 9 杀死
    - 18 继续运行
    - 19 暂停运行
5. `bg`: 将挂起的进程继续在**后台运行**
6. `fg`: 将挂起的进程继续在**前台运行**
7. `jobs`: 查看**当前终端下**是否有挂起的进程

### 2.2 进程相关函数
#### 2.2.1 创建子进程
- `pid_t fork(void)`
    1. 在当前的进程中创建子进程
    2. 返回值: 给当前的父进程返回子进程的 PID 号
#### 2.2.2 获得PID
1. `pid_t getpid(void)`
2. `pid_t getppid(void)`
#### 2.2.3 退出进程函数
1. `return`
2. `void exit(int status)` **(库函数, 结束刷新缓冲区)**
3. `void _exit(int status)`(系统调用, 不会刷新缓冲区)
#### 2.2.4 回收僵尸子进程
1. `pid_t wait(int *status)`
    1. 回收僵尸态子进程, 如果没有僵尸态子进程则阻塞, 如果有则执行后返回
    2. 参数说明
        - @status: 指向的对象用于存储子进程退出时的状态(也就是返回值)
        - @status == NULL: 忽略子进程退出时的状态
        - @status != NULL: 保存子进程退出时的状态
    3. 返回值: 成功返回僵尸态子进程的 PID, 否则返回 -1
2. `waitpid()`

## 3. [线程](./个人总结/文件IO_进程线程总结/4线程总结.c)

### 3.1 概念
#### 3.1.1 [线程与进程的区别](#215-关于子进程与父进程的一些事)
1. 相同点
    1. 都参与系统的调度
    2. 都有自己的ID值(标识符)
2. 不同点
    1. 进程拥有独立的 4G 虚拟空间, **而线程是共享内存的地址**
    2. 进程上下文的切换资源消耗比较大, 而线程是在进程内部切换, 资源比较小

### 3.2 线程相关函数
#### 3.2.1 线程创建
- `int pthread_create(pthread *thread, const pthread_attr_t *attr, void *(*start_rotine)(void *), void *arg)`
    - 创建一个线程, 调用线程执行函数<start_rotine>, 实现线程的创建
    - @thread: tid
    - @attr: 线程的属性(分离属性和结合属性),NULL表示默认属性(结合属性)
    - @start_routine: 让线程干的活(自己定义一个函数)

            void * fun(void * arg)
    - @arg: 给线程函数传递的参数
    - 返回值: **成功返回0**, 失败返回错误码, 但不一定会置errno(所以结合stderr, 使用fprintf打印)
#### 3.2.2 线程终止
1. `void pthread_exit(void *retval)`
    - 结束当前线程的执行(一般放在线程执行函数中)
    - 返回值: 线程退出的返回值, 如果没有返回值就写为NULL
2. **说明**
    1. 主线程中如果 main函数返回了 return 或是调用了 exit 退出了进程, 则所有其他线程也会终止(**进程状态影响线程状态**)
    2. 主线程如果是调用了 pthread_exit, 则**仅仅只会结束主线程**, 所有其他线程不会结束, 直到所有的线程结束的时候, 进程才会结束
#### 3.2.3 等待线程退出
1. `int pthread_join(pthread_t thread, void **retval)`
    1. 以**阻塞**的方式等待指定的线程退出, 并且释放线程占用的资源
    2. @thread: tid
    3. @retval: 获得`pthread_exit`带回的地址值
2. 与`pthread_exit`的区别
    1. `pthread_join`一般是主线程来调用, 它会让主线程等着(阻塞), 直到有子线程终止后立刻回收掉子线程的资源
    2. `pthread_exit`一般是用于子线程终止
#### 3.2.4 创建分离式线程
1. `int pthread_detach(pthread_t thread)`
    - 将线程标记为分离式线程
2. 特点
    - 线程结束的时候系统会自动回收掉资源, 这样就不需要`pthread_join`了(**非阻塞的方式回收资源, 也就是主线程也能运行**)
#### 3.2.5 取消一个线程
- `int pthread_cancel(pthread_t thread)`
#### 3.2.6 线程间的同步
1. 定义几个信号值(用于标记是否让该线程工作)

        sem_t sem_fun1, sem_fun2
2. 初始化信号值

        sem_init(sem_t, pshared, value)
        @pshared: 一般默认为 0
        @value: 你想让哪个线程先执行, 你就填 1
3. 等待接收信号值

        sem_wait(&sem_t)
        等待接收信号值, 收到的为 1就执行
4. 发送信号值

        sem_post(&sem_t)
        把信号发送出去, 让另一个线程干活
#### 3.2.7 线程间的互斥(锁)
1. 创建锁

        pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER
2. 让需要使用资源的线程把资源上锁, 以免其他线程抢用资源

        pthread_mutex_lock(&mutex)
3. 用完资源后解锁, 让别的线程用

        pthread_mutex_unlock(&mutex)
4. 用完锁后销毁锁

        pthread_destroy(&mutex)
#### 3.2.8 条件变量
1. 说明: 当两个线程满足供需关系时, 使用条件变量(定义一个全局变量来进行条件的产生(信号), 一个进程用于生产, 生产进程把货物产生好后把信号值改变, 另一个消费者进程得到消息后(条件满足)执行消费, 消费完后再改变信号值, 让生产者再生产)**利用了线程间共享全局变量的特性**
2. 初始化条件变量

        pthread_cond_t cond = PTHREAD_COND_INITIALIZER
3. 等待条件变量

        pthread_cond_wait
        阻塞直到条件满足
4. 唤醒因条件不满足而阻塞的线程

        1. pthread_cond_signal 唤醒至少一个阻塞的线程
        2. pthread_cond_broadcast 唤醒所有阻塞的线程
5. 销毁条件变量

        pthread_cond_destroy    