# 进程间通信

## [管道](./6进程与线程.md)

## 信号
### 说明
- 信号是**在软件层次上**对中断的一种模拟机制, 他是进程通信机制中唯一的异步通信机制
### 两个概念
1. 生成: 信号的产生
2. 捕捉: 信号的接收
### 信号的生命周期
1. 产生信号
2. 发送信号给进程
3. 信号的处理与注销
4. 内核进程(生成信号)-->用户进程(信号注册)-->用户进程(信号注销)-->信号处理

### 函数介绍
#### 注册信号处理函数: `sighandler_t signal(int signum, sighandler_t handler)`
##### 个人理解: `signal(<信号名>, <信号的处理>)`
##### 信号名: 通过`kill -l`查询
##### 常用的信号名
1. SIGINT(signal interrupt): 中断(信号在用户执行ctrl + c 时发出)
2. **SIGALRM: 定时器到时时发送信号**
3. SIGTSTP: 当用户执行 ctrl + z时发送信号
4. **SIGCHLD: 子进程状态改变时, 父进程会收到信号, 常用于回收僵尸态子进程**
##### 信号的处理
1. SIG_IGN: 忽略发出的信号
2. SIG_DFL: 采用系统默认的方式来处理信号
3. fun(自定义函数): 当收到信号时执行自定义的函数
4. 该参数是个函数指针 `void (*signal(int signum, void (*handler)(int)))(int)`signum是从<信号名>收到的信号值

#### **般信号对僵尸态子进程的处理方法**
1. 父进程采用`signal(SIGCHLD, hand_signal)`, 在接受到SIGCHLD信号时, 采用waitpid, 利用**非阻塞的方式**来释放他们的资源
2. 父进程采用`signal(SIGCHLD, SIG_IGN)`忽略SIGCHLD信号, 这样子进程结束后, 就不需要父进程来 wait 和释放资源

#### 信号的发送函数
- `int kill(pid_t pid, signum)`给指定pid发送信号值

#### 给自己发送信号值
- `int raise(int signum)`给自己发送信号值

#### 定时闹钟函数
- `unsigned int alarm(unsigned int seconds)`
- **说明:一个进程只能有一个闹钟事件, 若是多次使用alarm函数, 则闹钟时间会被刷新**

#### 挂起进程函数
- `int pause(void)`挂起一个进程, 直到进程收到一个信号才会继续执行

## IPC对象(Inter Process Communication)主要有三种通信方式(**ipcs用于显示系统的 IPC对象**)
### 规则
1. ID: 资源条目的唯一表示号
2. **Key: 应用程序读取资源时使用的参数**
3. 以下三种通信方式都需要用到key, 使用 `key_t ftok(const char *pathname, int proj_id)` 获得key
4. pathname 为你想指定的位置名, proj_id整个任意字符即可
5. **系统建立IPC通信时必须指定一个ID值, 通过 ftok获取就行了**

### 共享内存创建的过程
#### 1. 得到 key: `key_t key`
#### 2. 创建共享内存: `int shmget(key_t key, size_t size, int shmflg)`
1. key: IPC_PRIVATE: 用于亲缘进程通信, ftok: 非亲缘间通信
2. size: 申请的内存大小, 4k的倍数(如4096)
3. shmflg: IPC_CREAT|0666
4. **返回共享内存的 ID 号**
#### 3. 把共享内存和进程的地址联系起来 `void *shmat(int shmid, const void *shmaddr, int shmflg)`
1. shmid: 共享内存 ID 号
2. 填 NULL 让系统自动完成映射即可
3. shmflg: 0 表示可以读写, SHM_RDONLU 表示映射后只能读
4. **!!!失败返回 (void *) -1, 成功返回共享内存映射的地址空间**
#### 4. 撤销共享内存 `int shmdt(const void * shmaddr)`
1. shmaddr: shmat返回的地址值
#### 5. 删除共享内存 `int shmctl(int shmid, int cmd, struct shmid_ds *buf)`(shmat control)
1. shmid: shmget的返回值
2. cmd: IPC_RMID 删除共享内存
3. buf: NULL 表示不需要使用它

### 消息队列的创建过程
1. 你得有个需要传递的消息
```
typedef struct
{
    long type; // 消息类型
    char msgbuf[1024]; // 消息正文
}msg_t;
```
2. 你需要知道消息正文的长度
```
#define MSG_LEN (sizeof(msg_t) - sizeof(long))
```
3. 创建消息队列并设置消息类型
```
msgid = msgget(key, IPC_CREAT|0666);
msg.type = 100;
```
4. 一个进程发消息
```
msgsnd(msgid, &msg, MSG_LEN, 0) 0表示阻塞
```
5. 另一个进程收消息
```
msgrcv(msgid, &msg, MSG_LEN, 100, 0)
```
#### 
### 信号灯