# Linux基础1

## linux基础命令

### cp 命令

- '-f' 选项 强制复制
- '-i' 若有重复文件，会询问是否覆盖
- '-r' 递归复制，用于目录复制

### mv 命令

- `mv <旧文件> <新文件>` ： 改名

### rm 命令

- `rm -rf <文件夹>`： 递归删除文件夹

### 清屏命令

- `reset`：清屏后上翻无历史记录
- `clear`
- `Ctrl+L`

### 底栏模式

- r  文件名：导入文件内容到光标位置
- q! 强制退出

### 命令行模式

- v: 切换到可视模式
- I: 行首转插入
- vsp: 并排显示文件内容
- `, cc`: 快速注释

# Linux基础2

## 文件操作命令

### file(分析文件头部信息，识别文件类型

### cat

- '-n' 显示行号，包括空行
- '-b' 显示行号，但不显示空行行号

### head (显示一个文件的头几行，可加参数 -n <行数>)

### tail (显示一个文件的尾几行)

### more (文件内容较多时翻页查看, b: 向上翻页, 回车: 向下滚动一行)

### less (按行查看文件内容)

### rmdir (删除空文件夹)

## 目录和文件操作

### 文件类型

- '-' 普通文件
- 'l' 链接文件
- 'b' 块设备文件
- 'c' 字符设备文件
- 'p' 管道文件
- 's' 套接字文件

### 修改文件权限

- `chmode [u/g/o/a][+/-][r/w/x]`
- `chmode 权限数 文件名`

### 修改文件所属者

- `sudo chown <用户名称> <文件名>`

### 修改文件所属的组

- `sudo chgrp <组名称> <文件名>`

## 用户命令

- 设置root用户密码：sudo passwd root
- 添加用户： adduser `<username>`
- 删除用户： deluser `<username>`

## 搜索命令

### find (在指定的目录下找指定的文件)

- `find <pathname> [-options]`
- 若不添加参数，find默认搜索当前目录及子目录并且不过滤任何结果
- `-name` 按文件名查找文件 `find ./ -name test`
- `-perm` 按文件权限查找文件 `find ./ -perm 777`

### whereis (用于搜索命令的二进制文件，源代码文件，帮助文档)

- `whereis [-option] <filename>`
- '-b': 搜索二进制文件(只查找可执行文件的位置)
- '-m': 只查找帮助文档的位置
- '-l': 查看 whereis 的搜索路径

### which (和whereis类似, 查找系统PATH路径下的可执行文件)

### 通配符'*'

- 作用: 匹配任意长度的字符串

### 通配符'?'

- 作用: 匹配一个长度的字符

### `[...]`

- 作用: 匹配其中指定的一个字符
- `eg. ls file[1234].c`

### `[-]`

- 作用: 匹配指定的一个字符范围, '-' 代表一个范围
- `eg. [a-z], [A-Z], [0-9]`

### `[^...]` 或 `[!]`

- 作用: 除了其中指定的字符, 均可匹配

### `{..}`

- 作用: 生成序列
- `eg. touch file{1..10}.c`

## 文件系统组成

### 目录项(包括文件名和inode节点号)

- inode 含义: 系统会给每一个文件分配一个编号，这个编号就叫做inode号
- 查找inode号方式: `ls -i <文件名>` 或 `ll -i`

### inode表

- inode 表包含文件的一些信息，包括 inode号, 文件类型, 文件大小等
- 查看方式: `stat <文件名>`

### 数据块

- 含义: 文件具体存放的地方

## 软链接和硬链接

### 软链接

- **区别于硬链接**: 与原文件关联, 原文件改则改, 其改原文件也改, 其删原文件不删, **原文件删其内容删**(变为一个无内容的新文件)
- inode 号 与原文件不同
- 会高亮显示, 表明是一个链接文件

### 硬链接

- **区别于软链接**: 与原文件关联, 源文件改则改, 其改原文件也改, 其删原文件不删, **原文件删其内容不删**
- inode 号 与原文件相同
- 会显示为普通文件

# Linux基础3

## 解压缩命令

### gzip

- 特点: 压缩后**原文件删除****不能压缩目录**
- `gzip test.c` (生成后test.c消失)

### bzip2

- 特点: 压缩后**原文件删除****不能压缩目录**
- `bzip2 test.c`

### **tar**

- 特点: tar本身不具有压缩功能, 只有打包功能, 有关压缩及解压时调用其他的参数来完成(打包不减少压缩包体积)
- '-c': 创建
- '-x': 释放 tar 归档文件中的文件及目录
- '-z': 对归档文件进行**gzip**操作
- '-j': 对归档文件进行**bzip2**操作
- '-v': 显示过程
- '-f': 指定归档文件名***一定要放在选项的最后***
- '-C': 释放到指定目录 `eg. tar -xvf dir.tar.gz -C <指定目录>`
- gzip格式压缩: `tar -czvf <压缩包名>.tar.gz <需压缩文件目录>`
- bzip2格式压缩: `tar -cjvf <压缩包名>.tar.gz <需压缩文件目录>`

## **grep**

### 说明: 该指令匹配的是文本内部的内容, 不是过滤文件或属性的

### 使用方式: `grep [option] <需要匹配的字符或字符串> [FILE]`

### 参数

- '-n': 过滤文本时, 将过滤出来的内容 在文件内的行号 显示出来
- '-c': 显示匹配成功的有多少行
- '-C' <数字>: 匹配成功后, 将匹配行的前后各n行显示出来
- '-o': 只显示匹配成功的内容
- '-v': 反向过滤
- '-i': 忽略大小写
- '-l': 匹配成功之后, 将文本的文件名称打印出来
- '-R/ -r': 递归匹配

## '|'

- 管道连接符
- 连接两个命令, 把前一个命令的输出作为后一个命令的输入
- eg.`cat -n hello.c | grep -n "love"`

## wc

- 作用: 统计一个文件中行数, 单词个数, 大小(字节数)
- 用法: wc [option] [FILE]
- '-l': 只显示行数
- '-w': 只显示单词数
- '-c': 只显示文件的大小

## cut

### 作用: 从一个文本文件或文件流中提取文本列

### 案例: `cut [option] [FILE]`

### 参数

- '-d <分隔符>': 与 '-f' 一起使用
- '-f': 依据 '-d' 的分隔符将一段信息分隔成数段, 用 '-f'取出第极端

### 实例

- `cut -d <分隔符> -f <段数> 文件名`
- `head -1 /etc/passwd | cut -d ":" -f 1,3,4`

## 输入输出流

### 输入重定向

- `命令 < 文件`: 将指定文件的内容作为命令的输入(eg. cat < /etc/passwd>)
- `命令 << 分界符`: 用户在终端的输入作为命令的输入参数, 直到用户输入**分界符**时终止用户输入并作为命令参数输出
- `命令 <文件1> 文件2`: 将文件1的内容作为命令的输入参数, 将命令输出的内容添加到文件2中
  **若文件2存在, 则清空其原内容并替换为命令输出的内容**

### 输出重定向

- `命令 > 文件`: 将命令输出的内容添加到文件中**若文件存在, 则清空其原内容并替换为命令输出的内容**
- `命令 2> 文件`: 如果命令为**错误命令**, 则将其错误内容输入到文件中, **如果文件中已包含数据,则清空原数据写入新数据**
- `命令 >> 文件`: 将命令的输出结果添加到文件的尾部, **不会清空文件内的原有数据**
- `命令 2>> 文件`: 将错误命令的错误提示添加到文件的尾部, **不会清空文件中的原有数据**
- `命令 >> 文件 2>&1`/`命令 &>> 文件`

## 命令置换

- `ehco ls` 与 `echo 'ls'` 或 `echo "$(ls)"` 有区别
  第一个将 ls 理解为字符串, 而后面的 ls 是将其作为指令

## 挂载

- `mount <目标> <挂载目录>`

# 脚本

## 环境变量(/etc/profile)

### 查看环境变量的方式: `env / printenv`

### Linux系统中重要的10个环境变量

- HOME: 用户的主目录
- SHELL: 用户使用的 Shell 解释器名称
- **PATH**: 定义命令行解释器搜索用户执行命令的路径
- EDITOR: 用户默认的文本解释器
- RANDOM: 生成一个随机数字
- LANG: 系统语言
- HISTSIZE: 输出的历史命令记录条数
- HISTFILESIZE: 保存的历史命令记录条数

### 访问环境变量方式: `$变量名`

## PATH环境变量

### 通过配置PATH环境变量, 能快速的通过变量名获取内容

### 自定义PATH环境变量方式

- export: `export PATH=$PATH:/home/目标目录名`export 定义的环境变量仅当前终端有效, 终端退出后环境该环境消失
- 修改 ~/.bashrc 文件: 对**当前用户**永久有效
- 修改 /etc/profile 文件: 对**所有用户**永久有效

## 脚本编写

### 说明: 1、shell脚本中没有数据类型的概念, 都为字符串 `<br>`2、shell脚本中每一行相当于一条语句, 多条语句应用 ; 分隔开

### 变量定义

- `var=<value>`

### 变量的引用

- $<变量名>

### 单引号和双引号使用变量的区别

- 单引号: 单引号会将内容识别为字符串
- 双引号: 能识别'$', 将其当作变量处理

### 命令置换

- 例. 因为echo 默认会将命令参数识别为字符串, 所以通过对命令添加 **反引号 `** 后会将其识别为命令
- eg. ``echo `ls -l` ``

### unset

- 取消变量的定义

### 位置变量

- 使用方式: `./<脚本名> <命令行参数1> ..<命令行参数n>`
- '$0'(预定义变量): 显示终端输入的第一个字符串
- '$num': 第num个**命令行参数**
- '$#': 显示**命令行参数个数**
- '$?': 判断命令执行是否成功, **成功返回0, 否则返回非零**
- '\$@ 或 \$#': 获取所有命令行参数

### 运算与语句 (**等号左右必须空格, 否则视为赋值语句**)

#### **数值运算 若要使用C语法, 则用((数学运算))**

##### expr 语句

- `expr $<变量1> <+=\*/%> $<变量2>`: **乘法是反斜杠加星号**
- eg. ``val=`expr $a + $b` ``
- **注意反引号**

##### []

- `$[<变量1><+-*/%><变量2>]`
- eg. ``val=$[$val * 2]``

##### let 语句 <==> ((数学运算))

- 说明: let 语句中**使用变量可以不用添加$**
- eg. `let val=a*b`
- eg. `((a++))` `((val=a+b))`

#### 数值判断

- [ INT1 -eq INT2 ] INT1和INT2两数相等返回为真 ,=
- [ INT1 -ne INT2 ] INT1和INT2两数不等返回为真 ,<>
- [ INT1 -gt INT2 ] INT1大于INT2返回为真 ,>
- [ INT1 -ge INT2 ] INT1大于等于INT2返回为真,>=
- [ INT1 -lt INT2 ] INT1小于INT2返回为真 ,<
- [ INT1 -le INT2 ] INT1小于等于INT2返回为真,<=

#### 逻辑运算

- [ ! EXPR ] 逻辑非，如果 EXPR 是false则返回为真。
- [ EXPR1 -a EXPR2 ] 逻辑与，如果 EXPR1 and EXPR2 全真则返回为真。
- [ EXPR1 -o EXPR2 ] 逻辑或，如果 EXPR1 或者 EXPR2 为真则返回为真。

- [ ] || [ ] 用OR来合并两个条件
- [ ] && [ ] 用AND来合并两个条件

#### 字符串判断

- [ -z STRING ] 如果STRING的长度为零则返回为真，即空是真
- [ -n STRING ] 如果STRING的长度非零则返回为真，即非空是真
- [ STRING1 ]　 如果字符串不为空则返回为真,与-n类似
- [ STRING1 == STRING2 ] 如果两个字符串相同则返回为真
- [ STRING1 != STRING2 ] 如果字符串不相同则返回为真
- [ STRING1 < STRING2 ] 如果 “STRING1”字典排序在“STRING2”前面则返回为真。
- [ STRING1 > STRING2 ] 如果 “STRING1”字典排序在“STRING2”后面则返回为真。

#### **文件判断**

- [ -e FILE ] 判断文件是否存在
- [ -f FILE ] 文件是否为普通文件
- [ -d FILE ] 文件是否为一个目录
- [ -r FILE ] 文件是否可读
- '-w'
- '-x'
- eg. `test -f <文件> <==> [ -f <文件> ]`

#### echo

##### 显示普通字符串

- `echo "hello world"`
- `echo hello world`

##### 显示转移字符

- `echo "\" hello world "\"`
- '-e 参数'(开启转义): `echo -e "hello\n"`

##### 不换行显示

- '-c 参数': `echo -c "hello"`
- '-n 参数': `echo -n "hello"`

##### 原样输出字符串, 不转义或取变量值

- '使用单引号': `echo '$value' --> $value`

#### test语句(测试语句) <==> [空格 内容 空格](**注意!!! 中括号两边一定有空格**)

##### eg. `test 123 -eq 456 <==> [ 123 -eq 456 ]`

##### 参数

###### 数值测试

- `test <$变量1> <关系运算符> <$变量2>`

###### 字符测试

- `test <$变量1> <字符串运算符> <$变量2>`

#### 语句

##### 报错

```
    在匹配字符串相等时，我用了类似这样的语句：

if [ $STATUS == "OK" ]; then   

echo "OK"

fi

    在运行时出现了 [: =: unary operator expected 的错误，就一直找不到原因，尝试了删除等号两侧的空格和括号里的空格都不管用，最后baidu了一下，才找到原因。把语句改成这样就不会出错了.

if [[ $STATUS = "OK" ]]; 

then   

echo "OK"

fi

    究其原因，是因为如果变量STATUS值为空，那么就成了 [ = "OK"] ，显然 [ 和 "OK" 不相等并且缺少了 [ 符号，所以报了这样的错误。当然不总是出错，如果变量STATUS值不为空，程序就正常了，所以这样的错误还是很隐蔽的。

    或者用下面的方法也能避免这种错 误：if [ "$STATUS"x == "OK"x ]; then     echo

"OK"fi。当然，x也可以是其他字符。顺便提一点，shell中有没有双引号在很多情况下是一致的。

 
```

##### if

- eg.

```
if test $1 -eq $2 <==等价于> if [ $1 -eq $2 ]
# 多条件判断
if [ condition1 ] || [ condition2 ]
then
  command
elif <condition>
then
  command1
  command2
else
  command (注意: 对于shell的else不能空语句)
fi
```

- if的高级特性

```
IF高级特性：
双圆括号(( ))：表示数学表达式
在判断命令中只允许在比较中进行简单的算术操作，而双圆括号提供更多的数学符号，而且在双圆括号里面的'>','<'号不需要转意。

双方括号[[ ]]：表示高级字符串处理函数
双方括号中判断命令使用标准的字符串比较，还可以使用匹配模式，从而定义与字符串相匹配的正则表达式。

双括号的作用：
在shell中，[ $a != 1 || $b = 2 ]是不允许出，要用[ $a != 1 ] || [ $b = 2 ]，而双括号就可以解决这个问题的，[[ $a != 1 || $b = 2 ]]。又比如这个[ "$a" -lt "$b" ]，也可以改成双括号的形式(("$a"
 < "$b"))
```

- 判断是否是闰年

```
if [ $(($year%100)) -ne 0 ] && [$(($year%4)) -eq 0 ] || [ $(($year%400)) ]
```

##### case

- eg.

```
case <$变量> in
  "<target1>")
    command1
    ;;        #这里的 ;; 相当于 break
  "<target2>")
    command2
    ;;
  *)          # 这里的*)相当于 default
    command
esac
```

##### for

- eg.

```
for <value> in <list> # list 中的值用空格隔开, 也可以是$@
do
  command
done
```

##### while

- eg.

```
while [ comdition ]
do
  command
done
```
