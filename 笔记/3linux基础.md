# Linux

## 1. Linux 命令
### 1.1 vim的一些操作
1. `ctrl + v`: 可视
2. `vsp`: 分屏
3. `, cc`: 快速注释
### 1.2 基本指令
1. `cp`
  1. `-f`: 强制复制
  2. `-i`: 若有重复文件, 会询问是否覆盖
  3. `-r`: 递归复制, 用于目录复制 

### 1.3 文件操作
#### 1.3.1 显示文件内容
1. `cat`: 直接**抓取**文件中的内容
  1. `-n`: 显示行号
  2. `-b`: 显示行号, 但不显示空行行号
2. `head -n`: 显示一个文件的头n行
3. `tail -n`: 显示一个文件的尾几行
4. `more`: 以翻页的形式查看文件内容
5. `less`: 按行查看文件内容
6. `rmdir`: 删除空文件夹
#### 1.3.2 文件权限修改
1. 文件类型种类
  1. `-`: 普通文件
  2. `I`: 链接文件
  3. `b`: 块设备文件
  4. `c`: 字符设备文件
  5. `p`: 管道文件
  6. `s`: 套接字文件
2. `chmod`: 修改文件权限
3. `sudo chgrp <组名称> <文件名>`: 修改文件所属组
4. `sudo chown <用户名> <文件名>`: 修改文件所属者
#### 1.3.3 搜索文件命令
1. `find <pathname> [-option]`: 在指定目录下查找指定文件
  1. 无参数默认搜索当前目录及子目录并且不过滤任何结果
  2. `-name`: 按文件名查找`find ./ -name text`
  3. `-perm`: 按权限查找文件`find ./ -perm 777`
2. `whereis [-option] <filename>`: 用于搜索命令的二进制文件, 源代码文件, 帮助文档
  1. `-b`: 搜索二进制文件(只查找可执行文件的位置)
  2. `-m`: 只查找帮助文档的位置
  3. `-l`: 查看whereis的搜索路径
3. `which`: 查找系统PATH路径下的可执行文件
#### 1.3.4 查看文件信息
1. `ls -i`: 查看文件的 inode号(文件编号)
2. `stat <文件名>`: 查看 inode表
#### 1.3.5 **创建软链接与硬链接**
1. 软链接: 源文件删其内容删(变为一个无内容的新文件), **inode号与源文件不同**
2. 硬链接: 源文件删除其内容不删, **inode号与源文件相同**
#### 1.3.6 文件解压缩
1. `gzip`: 不能压缩目录且压缩后源文件删除
2. `bzip2`: 不能压缩目录且压缩后源文件删除
3. `tar`: 它其实只有打包功能, 有关压缩的功能通过其他参数来完成
  - `tar -czvf <压缩包名> tar.gz <需压缩的目录>`: gzip格式压缩
  - `tar -cjvf <压缩包名> tar.bz <需压缩的目录>`: bzip2格式压缩
  - `tar -xvf dir.tar.gz -C <指定目录>`: 解压缩到指定目录
#### 1.3.7 文本内部内容
1. `grep`: 过滤文件内部内容
  1. `-n`: 过滤文本时, 将过滤出来的内容在文件内的行号显示出来
  2. `-c`: 显示成功匹配的有多少行
  3. `-C <数字>`: 显示匹配成功行的前后 n行
  4. `o`: 只显示匹配成功的内容
  5. `-v`: 反向过滤
  6. `-i`: 忽略大小写
  7. `-l`: 列出匹配成功的文件名
  8. `-R/r`: 递归匹配
2. `|`: 管道连接符
3. `wc [option] <文件名>`: 统计一个文件中行数, 单词个数, 大小(字节数)
  1. `-l`: 只显示行数
  2. `-w`: 只显示单词个数
  3. `-c`: 只显示文件的大小
4. `cut [option] <文件名>`: 从文件中提取文本列

        cut -d <分隔符> -f <段数> <文件名>
        eg. head -1 /etc/passwd | cut -d ":" -f 1,3,4

### 1.4 用户相关命令
1. `sudo passwd root`: 设置root用户密码
2. `adduser <username>`: 添加用户
3. `deluser <username>`: 删除用户

### 1.5 正则表达[可结合搜索和创造文件指令使用](#133-搜索文件命令)
1. `*`: 通配符, 匹配任意长度的字符串
2. `?`: 匹配单个字符
3. `[...]`: 匹配其中的一个字符
        
        eg. ls file[1234].c
4. `[-]`: 匹配指定的一个字符范围

        eg. [a-z], [A-Z], [0-9]
5. `[^...] 或 [!]`: 除了其中指定的字符, 其他的均可匹配
6. `{..}`: 生成序列

        eg. touch file{1..10}.c

### 1.6 重定向
#### 1.6.1 输入重定向
- `命令 < 文件`: 将指定文件的内容作为命令的输入(eg. cat < /etc/passwd>)
- `命令 << 分界符`: 用户在终端的输入作为命令的输入参数, 直到用户输入**分界符**时终止用户输入并作为命令参数输出
- `命令 <文件1> 文件2`: 将文件1的内容作为命令的输入参数, 将命令输出的内容添加到文件2中
  **若文件2存在, 则清空其原内容并替换为命令输出的内容**
#### 1.6.2 输出重定向
- `命令 > 文件`: 将命令输出的内容添加到文件中**若文件存在, 则清空其原内容并替换为命令输出的内容**
- `命令 2> 文件`: 如果命令为**错误命令**, 则将其错误内容输入到文件中, **如果文件中已包含数据,则清空原数据写入新数据**
- `命令 >> 文件`: 将命令的输出结果添加到文件的尾部, **不会清空文件内的原有数据**
- `命令 2>> 文件`: 将错误命令的错误提示添加到文件的尾部, **不会清空文件中的原有数据**
- `命令 >> 文件 2>&1`/`命令 &>> 文件`

### 1.7 命令置换
- `ehco ls` 与 `echo 'ls'` 或 `echo "$(ls)"` 有区别
  第一个将 ls 理解为字符串, 而后面的 ls 是将其作为指令

### 1.8 挂载
- `mount <目标> <挂载目录>`

### 1.9 环境变量
1. `env 或 printenv`: 查看环境变量
2. `$<变量名 >`: 访问环境变量
3. **自定义环境变量**
  1. export: `export PATH=$PATH:/home/目标目录名`export 定义的环境变量仅当前终端有效, 终端退出后环境该环境消失
  2. 修改 ~/.bashrc 文件: 对**当前用户**永久有效
  3. 修改 /etc/profile 文件: 对**所有用户**永久有效


## 2. shell 脚本

### 2.1 规则
1. shell脚本中没有数据类型的概念, 都为字符串
2. shell脚本中每一行相当于一条语句, 多条语句应用 ; 分隔开
3. 开头必须有 `#! /bin/bash`
4. 单引号和双引号使用变量的区别
  - 单引号: 单引号会将内容识别为字符串
  - 双引号: 能识别'$', 将其当作变量处理
5. 变量定义
  - `var=<value>`: 不能有空格
6. 变量的引用
  - `$<变量名>`
7. 命令置换

        例. 因为echo 默认会将命令参数识别为字符串, 所以通过对命令添加反引号后会将其识别为命令
        eg. echo `ls -l`
8. `unset`: 取消变量的定义

### 2.2 位置变量
1. 使用方式: `./<脚本名> <命令行参数1> ..<命令行参数n>`
2. 参数说明
  - '$0'(预定义变量): 显示终端输入的第一个字符串
  - '$num': 第num个**命令行参数**
  - '$#': 显示**命令行参数个数**
  - '$?': 判断命令执行是否成功, **成功返回0, 否则返回非零**
  - '\$@ 或 \$#': 获取所有命令行参数

### 2.3 运算

#### 2.3.1 规则
1. **等号左右必须空格, 否则视为赋值语句**
2. **数值运算 若要使用C语法, 则用`((数学运算))`**

#### 2.3.2 数值运算
1. `expr $<变量1> <+=\*/%> $<变量2>`: **乘法是反斜杠加星号**

        eg. val=`expr $a + $b` 
        **注意反引号**
2. `[]`

        $[<变量1><+-*/%><变量2>]
        eg. val=$[$val * 2]
3. `let 语句 <==> ((数学运算))`
  - 说明: let 语句中**使用变量可以不用添加$**

          eg. let val=a*b
          eg. `((a++))` `((val=a+b))`

#### 2.3.3 数值判断
- [ INT1 -eq INT2 ] INT1和INT2两数相等返回为真 ,=
- [ INT1 -ne INT2 ] INT1和INT2两数不等返回为真 ,<>
- [ INT1 -gt INT2 ] INT1大于INT2返回为真 ,>
- [ INT1 -ge INT2 ] INT1大于等于INT2返回为真,>=
- [ INT1 -lt INT2 ] INT1小于INT2返回为真 ,<
- [ INT1 -le INT2 ] INT1小于等于INT2返回为真,<=

#### 2.3.4 逻辑运算
- [ ! EXPR ] 逻辑非，如果 EXPR 是false则返回为真。
- [ EXPR1 -a EXPR2 ] 逻辑与，如果 EXPR1 and EXPR2 全真则返回为真。
- [ EXPR1 -o EXPR2 ] 逻辑或，如果 EXPR1 或者 EXPR2 为真则返回为真。
- [ ] || [ ] 用OR来合并两个条件
- [ ] && [ ] 用AND来合并两个条件

#### 2.3.5 字符串判断
- [ -z STRING ] 如果STRING的长度为零则返回为真，即空是真
- [ -n STRING ] 如果STRING的长度非零则返回为真，即非空是真
- [ STRING1 ]　 如果字符串不为空则返回为真,与-n类似
- [ STRING1 == STRING2 ] 如果两个字符串相同则返回为真
- [ STRING1 != STRING2 ] 如果字符串不相同则返回为真
- [ STRING1 < STRING2 ] 如果 “STRING1”字典排序在“STRING2”前面则返回为真。
- [ STRING1 > STRING2 ] 如果 “STRING1”字典排序在“STRING2”后面则返回为真。

#### 2.3.6 **文件判断**
- [ -e FILE ] 判断文件是否存在
- [ -f FILE ] 文件是否为普通文件
- [ -d FILE ] 文件是否为一个目录
- [ -r FILE ] 文件是否可读
- '-w'
- '-x'
- eg. `test -f <文件> <==> [ -f <文件> ]`

#### 2.3.7 `echo`
1. 显示普通字符串
  - `echo "hello world"`
  - `echo hello world`
2. 显示转移字符
  - `echo "\" hello world "\"`
  - '-e 参数'(开启转义): `echo -e "hello\n"`
3. 不换行显示
  - '-c 参数': `echo -c "hello"`
  - '-n 参数': `echo -n "hello"`
4. 原样输出字符串, 不转义或取变量值
  - '使用单引号': `echo '$value' --> $value`

#### 2.3.8 `test`语句(测试语句)`test 123 -eq 456 <==> [ 123 -eq 456 ]`(**注意中括号两边一定有空格**)
1. 数值测试
  - `test <$变量1> <关系运算符> <$变量2>`
2. 字符测试
  - `test <$变量1> <字符串运算符> <$变量2>`

### 2.4 语句

#### 2.4.1 一些报错原因

        在匹配字符串相等时，我用了类似这样的语句：
        if [ $STATUS == "OK" ]; then   
        echo "OK"
        fi
        在运行时出现了 [: =: unary operator expected 的错误，就一直找不到原因，尝试了删除等号两侧的空格和括号里的空格都不管用，最后baidu了一下，才找到原因。把语句改成这样就不会出错了.
        if [[ $STATUS = "OK" ]]; 
        then   
        echo "OK"
        fi
        究其原因，是因为如果变量STATUS值为空，那么就成了 [ = "OK"] ，显然 [ 和 "OK" 不相等并且缺少了 [ 符号，所以报了这样的错误。当然不总是出错，如果变量STATUS值不为空，程序就正常了，所以这样的错误还是很隐蔽的。
        或者用下面的方法也能避免这种错误
        if [ "$STATUS"x == "OK"x ]; then
        echo "OK"
        fi
        当然，x也可以是其他字符。顺便提一点，shell中有没有双引号在很多情况下是一致的。

#### 2.4.2 `if`
1. eg

        if test $1 -eq $2 <==等价于> if [ $1 -eq $2 ]
        # 多条件判断
        if [ condition1 ] || [ condition2 ]
        then
          command
        elif <condition>
        then
          command1
          command2
        else
        command (注意: 对于shell的else不能空语句)
        fi
2. if 的高级特性

        1. 双圆括号(( ))：表示数学表达式
        在判断命令中只允许在比较中进行简单的算术操作，而双圆括号提供更多的数学符号，而且在双圆括号里面的'>','<'号不需要转意。
        2. 双方括号[[ ]]：表示高级字符串处理函数
        双方括号中判断命令使用标准的字符串比较，还可以使用匹配模式，从而定义与字符串相匹配的正则表达式。
        3. 双括号的作用：
        在shell中，[ $a != 1 || $b = 2 ]是不允许出，要用[ $a != 1 ] || [ $b = 2 ]，而双括号就可以解决这个问题的，[[ $a != 1 || $b = 2 ]]。又比如这个[ "$a" -lt "$b" ]，也可以改成双括号的形式(("$a"
         < "$b"))
3. 判断是否是闰年

        if [ $(($year%100)) -ne 0 ] && [$(($year%4)) -eq 0 ] || [ $(($year%400)) ]

#### 2.4.3 `case`
- eg

        case <$变量> in
          "<target1>")
            command1
            ;;        #这里的 ;; 相当于 break
          "<target2>")
            command2
            ;;
          *)          # 这里的*)相当于 default
            command
        esac
#### 2.4.5 `for`
- eg

        for <value> in <list> # list 中的值用空格隔开, 也可以是$@
        do
          command
        done
#### 2.4.6 `while`
- eg

        while [ comdition ]
        do
          command
        done