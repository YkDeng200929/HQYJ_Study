# IO多路复用
- 目的
    1. 解决阻塞IO影响其他程序执行和非阻塞IO造成的资源浪费
    2. IO多路复用可以同时监听多个IO操作

## 1. 何为阻塞IO与非阻塞IO
---
### 1.1 阻塞IO
1. 读阻塞
    - 当程序执行到对应函数时, 如果没有读取到函数对应的数据, 则会阻塞在函数处, 直到读取到数据为止
2. 写阻塞
    - 写入缓冲区空间不足时就会造成阻塞, 直到有足够的写入空间才执行(如 **sendto**)
#### 1.1.1 例如
1. `fget`
2. `read`
3. `write`
4. `recvfrom`
#### 1.1.2 阻塞IO的缺陷
- 可能会干扰其他程序执行
### 1.2 非阻塞IO
- 程序执行到该类函数时不阻塞继续运行, **直接返回错误的结果(不断返回错误值)**
#### 1.2.1 如何将函数设置为非阻塞
1. 调用`int fcntl(int fd, int cmd,...)`
2. 参数说明
    1. @fd: 要设置非阻塞IO的文件描述符
    2. @cmd **先获取属性后再设置非阻塞**
        - F_GETFL: 获取对应的IO属性
        - F_SETFL: 设置对应的属性
    3. @arg: 
        - 当cmd填 F_SETFL时, 为要设置的属性
        - 当cmd填 F_GETFL时, 不用填写此函数
3. 示例

                int flag = -1;
                // 先获取属性, 然后再设置为非阻塞
                flag = fcntl(0, F_GETFL, 0)
                flag |= O_NONBLOCK;
                fcntl(0, F_SETFL, flag);
#### 1.2.2 非阻塞IO的缺陷
- 设置成非阻塞后，内核会循环判断有没有相关资源，如果没有会报错，有则执行，浪费内核空间

## 2. select
- `int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct tmieval *timeout)`
### 2.1 参数说明
1. @nfds： 文件描述符 + 1(文件描述符表容量)
2. @readfds: 文件描述符表
3. @writefds: 文件描述符写表
4. @exceptfds: 文件描述符异常处理表
5. @timeout: 超时时间
### 2.2 流程
1. 定义一张文件描述符表, 进行初始化
2. 通过select函数检测文件描述符
3. 记录需要检测的表, 轮询更新并处理需要操作的文件描述符

## 3. poll机制

## 4. epoll机制