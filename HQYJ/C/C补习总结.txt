Linux概述
常用的命令
路径：
	相对路径：相对于当前的路径来说
	绝对路径：从/[根目录]开始
	1、pwd :查看当前路径
	2、cd :进入目录
		. --> 当前目录
		.. --> 父目录
		~ --> 用户主目录
		/ --> 根目录
	3、ls :查看路径下的内容
		用法：ls 
			  ls 路径
		选项：
			  -l : 查看路径下的详细信息
			  -a : 查看路径下的所有文件
	4、mkdir :创建一个文件夹[目录]
	5、touch :创建一个文件
	6、cp :复制
		用法：cp 源路径 目标路径
		选项：-rf : 用于拷贝文件夹
	7、mv :移动
		用法：mv 源路径 目标路径
	   mv :重命名
	    用法：mv 路径/旧名字 路径/新名字
	8、rm :删除
		用法：rm 文件名
		选项：-rf ：用于删除文件夹
	9、cat :查看文件内容
		选项：-n :显示行号
	
编辑器：写.c文件
vim三种模式
1、命令模式[进入默认的模式]
	i : 进入插入模式
	yy : 复制光标所在行
	dd : 剪切光标所在行
	p : 粘贴
	[n]yy : 复制从光标下的n行
	[n]dd : 剪切从光标下的n行
	空格 / "shift + :" : 进入底行模式
2、插入模式：书写代码
	插入模式进去命令模式：
3、底行模式
	w : 保存
	q : 退出
	wq : 保存并退出
	q! : 强制退出
	[n], [N]y :复制n到N行
	
编译器：将.c文件编译成可执行文件
gcc	
1、预处理阶段：处理以#开头的语句
2、编译阶段：将文件翻译成汇编语言
3、汇编阶段：将汇编语言转换成普通二进制文件[不能被执行]
4、链接阶段：链接底层库，生成可执行文件

进制之间的转换：
二进制：0 1
	规则：逢2进1
	二进制 转换成 十进制：
		位权 ： 2^(n - 1)
	二进制 转换成 八进制：
		0	000
		1	001
		2	010
		3	011
		4	100
		5	101
		6	110
		7	111
	二进制 转换成 十六进制：
		0	0000
		1	0001
		2	0010
		3	0011
		4	0100
		5	0101
		6	0110
		7	0111
		8	1000
		9	1001
		a	1010
		b	1011
		c	1100
		d	1101
		e	1110
		f	1111
八进制: 0 1 2 3 4 5 6 7
	规则：逢8进1
	八进制 转换成 十进制：
		位权 ： 8^(n - 1)
十进制: 0 1 2 3 4 5 6 7 8 9
	十进制 转成 二进制：
		1、整数：除2取余，逆向排序
		   小数：乘2取整，顺序排序
		2、128 64 32 16 8 4 2 1
			eg:
			十进制：86
					01010110
十六进制:0 1 2 3 4 5 6 7 8 9 a b c d e f
	规则：逢16进1
	十六进制 转换成 十进制：
		位权 ： 16^(n - 1)
	
原码，反码，补码 ：因为计算机中是按照补码存放
一般都是8位，或者是8的倍数
最高位是符号位，剩余是数值位
正数：
	符号位是0
	原码，反码，补码都是一样的
负数：
	符号位是1
	原码：符号位 + 数值位[二进制]
	反码：符号位不变，数值位在原码的基础上取反
	补码：符号位不变，数值位在反码的基础上+1
1、正数的原码反码补码都是其本身
2、负数求补码：反码 + 1 (从原码的低位找到第一个1，包括这个1在内，低位所有数据不变，数据位其余全部取反)
3、负数补码求反码：补码 -1，符号位不变，其余全部取反

C语言的框架：
int main()
{
	//C语句
	return 0;
}

宏定义：
定义：
	#define 宏名 宏值
作用：
	再预处理阶段，会将宏名替换成宏值
	这里的替换是原样替换，不要加()
	
条件编译：
	#if 宏名
	//C语言1
	#else
	//C语句2
	#endif
	运行过程：
		宏名为真[非0]，执行 C语句1
		宏名为假[0]，执行 C语句2
		
是否定义该宏：
	#ifndef 宏名
	//C语句1 
	#endif
	运行过程：
		没有定义 该宏，执行C语句1
		定义 该宏，不执行C语句1

常量：在程序运行过程中，值不变
	1、整型常量：10， 20
	2、实型常量[浮点型常量]：小数
		e/E --> 指数形式
		e/E 前后都要有数字，后面只能是整数
	3、字符型常量：''
		本质上，存的是对应的ASCII码
	4、字符串常量：""
		系统会在后面加上'\0'

变量：在程序运行过程中，值可变
	1、基本类型			字节数								范围
		整型
		short			2				有符号/无符号
		int				4				有符号/无符号
		long int		4[32] 8[64]		有符号/无符号
		long long int	8				有符号/无符号
		实型[浮点型]
		float			4				有符号
		double			8				有符号
		字符型
		char			1				有符号/无符号		有符号:[-128, 127] 无符号:[0, 255]
	2、数组
	3、指针

输入输出函数：
类型					格式化输入[出]符
十进制整型[负数]		%d %ld %lld 
八进制整型				%#o
十六进制整型			%#x
浮点型					%f %e %lf
字符型					%c
字符串					%s
地址					%p
输入函数：
	scnaf("格式化输入符1格式化输入符2...", 变量1的地址, 变量1的地址,...);
	eg:
		int a;
		scanf("data:%d", &a); --> 必须输入的格式是 "data:数字"
输出函数：
	printf("格式化输出符/字符串常量/转义字符", 输出列表);
	字符串常量：
		原样输出
	转义字符：
		换行：   \n
		制表符： \t
	输出列表：
		根据""格式化输出符的格式，要做到一一对应

表达式 ：所有的表达式有一个明确的值

运算符：
	1、算术运算符：+ - * \ % ++ --
		前置++/--
			int i = 0;
			int j = ++[--]i;
				[i = i +[-] 1; j = i]
		后置++/--
			int i = 0;
			int j = i++[--];
				[j = i; i = i +[-] 1]
	2、关系运算符：== != > < >= <=
	3、逻辑运算符：&& || !
			表达式1 && 表达式2 --> 表达式1，表达式2都为真，整体为真
			表达式1 || 表达式2 --> 表达式1，表达式2其中一个为真，整体为真
			短路特性：
				表达式1 && 表达式2 --> 表达式1为假的话，整体就为假，不会在计算表达式2
				表达式1 || 表达式2 --> 表达式1为真的话，整体就为真，不会在计算表达式2
	4、三目运算符：	表达式1 ? 表达式2 : 表达式3
		规则：
			表达式1为真，计算表达式2
			表达式1为假，计算表达式3
	5、位运算符：& | ~ ^ >> <<
			对二进制操作
			^ ：相同为0，不同为1
			<< : 符号位不变，高位丢弃，低位补0
			>> : 逻辑右移：高位补0，低位丢弃
				 算术右移：正数高位补0，低位丢弃
						   负数高位补1，低位丢弃
	6、赋值运算符：= += -+ *= /+ %=
	7、优先级
		技巧：需要先运算 加()
		
控制语句：
判断语句：
1、if
	1> 单分支
	if(表达式)
	{
		//C语句
	}
	规则：	
	表达式为真，执行C语句
	表达式为假，不执行C语句
	2> 双分支
	if(表达式)
	{
		//C语句1
	}
	else
	{
		//C语句2
	}
	规则：	
	表达式1为真，执行C语句1
	表达式2为假，执行C语句2
	3> 多分支
	if(表达式1)
	{
		//C语句1
	}
	else if(表达式2)
	{
		//C语句2
	}
	...
	else
	{
		//C语句n
	}
	规则：	
	表达式1为真，执行C语句1，结束整个if判断
	表达式1为假，表达式2为真，执行C语句2，结束整个if判断
	表达式1，2..n都为假，执行C语句n，结束整个if判断
2、switch case
	switch(表达式)
	{
	case 常量1:
		//C语句1
		break;
	case 常量2:
		//C语句2
		break;
	....
	default :
		//C语句n
		break;
	}
	规则：
	计算表达式的结果ret
	ret匹配case后面的常量，匹配成功后，执行后面后面语句，遇到break,结束整个switch语句

循环语句：
	1>while()
		while(表达式)
		{
			//循环体
		}
		规则：
		表达式为真，进入循环体
		表达式为假，结束整个while循环
	2>do{}while();
		do
		{
			//循环体
		}while(表达式);
		规则：
		执行一次循环体
		判断表达式为真，进入循环体
		判断表达式为假，结束整个do..while循环
	3>for()
		for(表达式1; 表达式2; 表达式3)
		{
			//循环体
		}
		规则：
		执行表达式1
		判断表达式2为真，执行完循环体
		执行表达式3
		判断表达式2为真，执行完循环体
		直到判断表达式2为假，结束整个for循环
控制语句：
	continue:只能在循环中使用
			跳出本轮循环，进入下一轮循环
	break:可以再switch和循环语句中使用
			破坏离他最近的整个循环
无条件跳转语句：goto
	goto lable;

一维数组：相同类型的集合
定义和初始化： 数据类型 数组名[数组元素] = {};
	初始化：必须要定义的时候才能使用
			可以全部初始化，部分初始化
				部分初始化，未初始化的数据默认为0
使用：
	数组名[数组下标]
		下标：从0开始
特殊的一维数组：字符数组
字符串和字符数组的区别：字符串的最后一定是'\0'结尾
						字符数组不一定
		字符串一定是字符数组
		字符数组不一定是字符串
	字符数组可以存字符串
	定义： char 数组名[元素个数] = {};
	初始化：
		eg：
			char buf[] = {'h', 'e', 'l', 'l', 'o', '\0'};
			char buf[] = "hello";
			char buf[6] = {"hello"};
常用的性质：
1、数组名 通常情况下 表示该数组首元素的地址
	      两种特殊情况下 表示整个数组 --> sizeof(数组名) &数组名
2、获取数组的大小：sizeof(数组名)
3、获取元素个数：sizeof(数组名) / sizeof(元素)

字符串常用函数：
	1、单个字符的输入输出：
		getchar()
		putchar('a')
	2、字符串的输入输出：
		gets(buf)
		fgets(buf, size, stdin)
		puts(buf)
	3、获取字符串的长度:'\0'之前的有效字符个数
		#include <string.h>
		strlen(buf)
	4、字符串的拷贝
		#include <string.h>
		strcpy(dest, src);
	5、字符串的追加
		#include <string.h>
		strcat(dest, src);
	6、字符串的比较
		#include <string.h>
		strcmp(buf1, buf2);
		逐个比较
		
二维数组：
定义：告诉编译需要分配多少内存
	数据类型 数组名[行][列]
初始化：
	可以省略行，不能省略列
	eg:
		int a[2][3] = {{1, 2, 3}, {4, 5, 6}};
		int a[2][3] = {1, 2, 3, 4, 5, 6}
常用的性质：int a[2][3]
1、该数组大小：
	sizeof(数组名)
2、该数组的元素个数：
	sizeof(数组名) / sizeof(元素)
3、行数：
	sizeof(数组名) / sizeof(二维数组的第一个元素)
	sizeof(a) / sizeof(a[0])
4、列数：
	sizeof(二维数组的第一个元素) / sizeof(二维数组的第一个元素里面的第一个元素)
	sizeof(a[0]) / sizeof(a[0][0])

行指针和列指针
	行指针：本质上是一个指针，指向的整行
	列指针：本质上是一个指针，指向的这一行中单个元素
	int a[2][3];
	int a[2][3] = {{1,2,3}, {4,5,6}}
	行指针：
	也就是将 a 看作 二维数组 首行 地址 (也就是 {1,2,3} 的地址 也就是 &a[0])
			a <==> &a[0] --> int (*)[3]
			a + 1  -偏移量-> 一整行
	列指针：
	也就是将 a[0] 看作 二维数组 首行 首元素 地址 (也就是 元素1 的地址 也就是 &a[0][0] 也就是 将a[0] 看作 a[0][0] 的数组名，而数组名为数组首元素地址)
			a[0],a[1]是一个一维数组
			a[0] <==> &a[0][0] --> int *
			a[0] + 1 -偏移量-> 一个元素
	
指针
定义：
	1>目标数据类型
	2>目标数据类型 * --> 指针类型
	3>目标数据类型 *指针变量名 --> 指针类型 指针变量名

定义指针没有初始化就是一个野指针[随机值，非法地址]：野指针就是一个指向随机地址的指针，不受程序控制
要使用这个指针，要给合法地址

&：获取变量的地址
	结果类型 ： 加 *
*：间接引用符
	* 地址
	结果类型 ： 减 *
	注意： * 地址 --> 根据目标数据类型决定获取多少个字节
	eg:
		int a = 0x12345678;
		char *p = (char *)&a;
指针大小：32位 4字节
		  64位 8字节
指针偏移量：根据目标数据类型决定获取的
		
大端模式：高地址对低数据位
小端模式：高地址对高数据位

函数：
定义：
	返回值类型 函数名(形参类型1 形参变量1, 形参类型2 形参变量2...)
	{
		//C语句
		return 返回值;
	}
调用：
	函数名(实参);
传参：
	值传参：函数内改变，不影响实参
	地址传承：函数内改变，影响实参

局部变量 vs 全局变量

局部变量：
定义：数据类型 变量名;
定义位置：函数体内或者语句块内定义
作用域：从该变量定义开始，到函数结束
		只能在定义该变量的函数体(语句块)内使用
生命周期：定义该变量 到 函数结束
		  函数结束后就会释放内存
初始化值：未初始化，随机值
内存的存放位置：栈区

全局变量：
定义：数据类型 变量名;
定义位置：函数体外部定义
作用域：源程序中的所有文件都可以使用
		定义该变量的源文件中，从该变量定义开始往下
		其他文件需要使用，要声明
生命周期：main()函数结束
初始化：未初始化，默认为0
内存的存放位置：静态区

静态局部变量 vs 静态全局变量

静态局部变量：
定义：static 数据类型 变量名;
定义位置：函数体内或者语句块内定义
作用域：从该变量定义开始，到函数结束
		只能在定义该变量的函数体(语句块)内使用
生命周期：main()结束
初始化值：未初始化，默认为0
		  只初始化一次
内存的存放位置：静态区

静态全局变量：
定义：static 数据类型 变量名;
定义位置：函数体外部定义
作用域：只能在定义该变量的源文件中使用
生命周期：main()函数结束
初始化：未初始化，默认为0
		只初始化一次
内存的存放位置：静态区


指针数组vs数组指针vs函数指针vs指针函数 --> 看后面两个字，后面两个字就是本质
指针数组：本质是一个数组，里面的元素是指针变量
指针函数：本质是一个函数，返回值类型是指针类型
数组指针：本质是一个指针，指向的是一个数组
函数指针：本质是一个指针，指向的是一个函数


两种排序
冒泡排序：
int a[5];
int i = 0, j = 0;
int temp;
int len = sizeof(a) / sizeof(a[0]);
for(i = 0; i < len - 1; i++)
{
	for(j = 0; j < len - 1- i; j++)
	{
		//升序
		if(a[j] > a[j + 1])
		{
			temp = a[j];
			a[j] = a[j + 1];
			a[j + 1] = temp;
		}
		//降序
		if(a[j] < a[j + 1])
		{
			temp = a[j];
			a[j] = a[j + 1];
			a[j + 1] = temp;
		}
	}
}
简单选择排序：
int a[5];
int i = 0, j = 0;
int temp;
int len = sizeof(a) / sizeof(a[0]);
int min[max] = 0;
int n = 0;

for(i = 0; i < len - 1; i++)
{
	min[max] = a[i]
	n = i;
	for(j = i + 1; j < len; j++)
	{
		if(min[max] >[<] a[j])
		{
			min[max] = a[j];
			n = j;
		}
	}
	if(n != i)
	{
		temp = a[n];
		a[n] = a[i];
		a[i] = temp;
	}
}




	
	
	
	
	
	
	
	
	
	
	
	
	
	