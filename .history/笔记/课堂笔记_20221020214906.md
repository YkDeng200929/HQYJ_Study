# Day2

## linux基础命令

### cp 命令

- '-f' 选项 强制复制
- '-i' 若有重复文件，会询问是否覆盖
- '-r' 递归复制，用于目录复制

### mv 命令

- `mv <旧文件> <新文件>` ： 改名

### rm 命令

- `rm -rf <文件夹>`： 递归删除文件夹

### 清屏命令

- `reset`：清屏后上翻无历史记录
- `clear`
- `Ctrl+L`

### 底栏模式

- r  文件名：导入文件内容到光标位置
- q! 强制退出

### 命令行模式

- v: 切换到可视模式
- I: 行首转插入
- vsp: 并排显示文件内容
- `, cc`: 快速注释

# Day3

## 计算机的最小集成单位为位(bit)，二进制的位数一般为8位，16位，32位，64位(也就是8的倍数)，把八位二进制数称为一个字节(计算机存储中最基本的存储单位为直接)

## 进制

### 十进制

- 基数：10

### 二进制

- 二进制->十进制：(0.101)2 = 1x2^(-1) + 0x2^(-2) + 1x2^(-3)
- 十进制->二进制：除基取余![1665493388682](image/课堂笔记/1665493388682.png)
- 十进制->二进制(小数部分)：![1665493904804](image/课堂笔记/1665493904804.png)
- 位权：2^(n-1)

### 八进制(0开头)

- 基数：8
- 八进制->十进制：(377)8 = 3x8^2 + 7x8^1 + 7x8^0
- 位权：8^(n-1)

### 十六进制数

- 可使用的数码：0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f
- 基数：16
- 十六进制->十进制：0x27b = 2x16^2 + 7x16^1 + bx16^0
- 0x27b + 0x18a = 0x405

### 进制间的相互转换

- 二进制->八进制：每三位为八进制一位
- 八进制->二进制：每一位为二进制三位

### 计算机编码

#### 符号位: 最高位表示符号位(0 为正, 1为负)

#### 原码(一般以八位二进制数为主)

- 7(8位)：`0 000 0111` --> 扩展为16位：`0 000 0000 0000 0111`
- -7(8位)：`1 000 0111` -- 扩展为16位：`1 000 0000 0000 0111`
- +0(8位)：`0 000 0000`
- -0(8位)：`1 000 0000`

#### 反码

- 0变1，1变0
- 7(8位)反码：`0 000 0111` -- 扩展为16位：`0 000 0000 0000 0111`
- -7(8位)反码：`1 111 1000` -- 扩展为16位：`1 111 1111 1111 1000`
- +0：`0 000 0000`
- -0：`1 111 1111`

#### 补码

- 7(8位)补码：`0 000 0111` -- 扩展为16位：`0 000 0000 0000 0111`
- -7(8位)补码：`1 111 1111 1111 1001` -- 扩展为16位：`1 111 1111 1111 1001`
- 0的补码：`0000 0000`
- 特殊的补码：`1 000 0000`/`1 1000 0000` 最高位的1是符号位和绝对值重叠的位
- 特殊的补码：-0：`1 0000 0000` 规定-0表示-128
- 数据在内存中总是以补码的形式存放的，最高位为符号位
- 求补码的技巧：从数据的低位找到第一个1, 包括这个1在内, 低位所有数据不变, 数据位其余全部取反
  原码：`1 011 0100`    高位  <------- 低位
  反码：`1 100 1011`
  补码：`1 100 1100`

#### 补码转换成原码

- 补码 -1， 符号位不变， 按位取反
- -10：
  原码： `1 000 1010`
  补码:  `1 111 0110`
  取反：`1 111 0101`

#### 位运算符

- ~ 按位取反
- & 按位与：乘运算
- ^ 按位异或：两位相同取0，加运算
- | 按位或：加运算
- << 左移位：该操作产生一个新对象的值

#### 总结

- 正数的原码，反码，补码与原数相同

# Day12

## 二维数组与指针 `(int (*p)[2] = a)`

### 行指针(也就是将 `a[i]` 看作 二维数组 行地址)

- `p + 1 <==> &a[0] + 1 <==> &a[1]`
- `*(p + 1) <==> *(&a[1]) <==> a[1] <==> &a[1][0]`
- `*(*(p + 1)) <==> *(&a[1][0]) <==> a[1][0]`
- `结论：a[i][j] <==> *(a[i] + j) <==> *(*(a + i) + j) <==> *(p[i] + j) <==> p[i][j]`

### 列指针

- `a[0] <==> &a[0][0]`
- `a[0] + 1 <==> &a[0][0] + 1 == &a[0][1]`

# 1017测试

- C语言中，运算对象必须是整形数的运算符是 `%`
- 表达式 `!x` 等价于 `x == 0`

# Linux基础

## 文件操作命令

### file(分析文件头部信息，识别文件类型

### cat

- '-n' 显示行号，包括空行
- '-b' 显示行号，但不显示空行行号

### head (显示一个文件的头几行，可加参数 -n <行数>)

### tail (显示一个文件的尾几行)

### more (文件内容较多时翻页查看, b: 向上翻页, 回车: 向下滚动一行)

### less (按行查看文件内容)

### rmdir (删除空文件夹)

## 目录和文件操作

### 文件类型

- '-' 普通文件
- 'l' 链接文件
- 'b' 块设备文件
- 'c' 字符设备文件
- 'p' 管道文件
- 's' 套接字文件

### 修改文件权限

- `chmode [u/g/o/a][+/-][r/w/x]`
- `chmode 权限数 文件名`

### 修改文件所属者

- `sudo chown <用户名称> <文件名>`

### 修改文件所属的组

- `sudo chgrp <组名称> <文件名>`

## 用户命令

- 设置root用户密码：sudo passwd root
- 添加用户： adduser `<username>`
- 删除用户： deluser `<username>`

## 搜索命令

### find (在指定的目录下找指定的文件)

- `find <pathname> [-options]`
- 若不添加参数，find默认搜索当前目录及子目录并且不过滤任何结果
- `-name` 按文件名查找文件 `find ./ -name test`
- `-perm` 按文件权限查找文件 `find ./ -perm 777`

### whereis (用于搜索命令的二进制文件，源代码文件，帮助文档)

- `whereis [-option] <filename>`
- '-b': 搜索二进制文件(只查找可执行文件的位置)
- '-m': 只查找帮助文档的位置
- '-l': 查看 whereis 的搜索路径

### which (和whereis类似, 查找系统PATH路径下的可执行文件)

### 通配符'*'

- 作用: 匹配任意长度的字符串

### 通配符'?'

- 作用: 匹配一个长度的字符

### `[...]`

- 作用: 匹配其中指定的一个字符
- `eg. ls file[1234].c`

### `[-]`

- 作用: 匹配指定的一个字符范围, '-' 代表一个范围
- `eg. [a-z], [A-Z], [0-9]`

### `[^...]` 或 `[!]`

- 作用: 除了其中指定的字符, 均可匹配

### `{..}`

- 作用: 生成序列
- `eg. touch file{1..10}.c`

## 文件系统组成

### 目录项(包括文件名和inode节点号)

- inode 含义: 系统会给每一个文件分配一个编号，这个编号就叫做inode号
- 查找inode号方式: `ls -i <文件名>` 或 `ll -i`

### inode表

- inode 表包含文件的一些信息，包括 inode号, 文件类型, 文件大小等
- 查看方式: `stat <文件名>`

### 数据块

- 含义: 文件具体存放的地方

## 软链接和硬链接

### 软链接

- **区别于硬链接**: 与原文件关联, 原文件改则改, 其改原文件也改, 其删原文件不删, **原文件删其内容删**(变为一个无内容的新文件)
- inode 号 与原文件不同
- 会高亮显示, 表明是一个链接文件

### 硬链接

- **区别于软链接**: 与原文件关联, 源文件改则改, 其改原文件也改, 其删原文件不删, **原文件删其内容不删**
- inode 号 与原文件相同
- 会显示为普通文件

# Linux基础2

## 解压缩命令

### gzip
- 特点: 压缩后**原文件删除**  
**不能压缩目录**
- `gzip test.c` (生成后test.c消失)

### bzip2
- 特点: 压缩后**原文件删除**  
**不能压缩目录**
- `bzip2 test.c`

### **tar**
- 特点: tar本身不具有压缩功能, 只有打包功能, 有关压缩及  
解压时调用其他的参数来完成(打包不减少压缩包体积)
- '-c': 创建
- '-x': 释放 tar 归档文件中的文件及目录
- '-z': 对归档文件进行**gzip**操作
- '-j': 对归档文件进行**bzip2**操作
- '-v': 显示过程
- '-f': 指定归档文件名***一定要放在选项的最后***
- '-C': 释放到指定目录 `eg. tar -xvf dir.tar.gz -C <指定目录>`
- gzip格式压缩: `tar -czvf <压缩包名>.tar.gz <需压缩文件目录>`
- bzip2格式压缩: `tar -cjvf <压缩包名>.tar.gz <需压缩文件目录>`

## **grep**

### 说明: 该指令匹配的是文本内部的内容, 不是过滤文件或属性的

### 使用方式: `grep [option] <需要匹配的字符或字符串> [FILE]`

### 参数
- '-n': 过滤文本时, 将过滤出来的内容 在文件内的行号 显示出来
- '-c': 显示匹配成功的有多少行
- '-C' <数字>: 匹配成功后, 将匹配行的前后各n行显示出来
- '-o': 只显示匹配成功的内容
- '-v': 反向过滤
- '-i': 忽略大小写
- '-l': 匹配成功之后, 将文本的文件名称打印出来
- '-R/ -r': 递归匹配

## '|'
- 管道连接符
- 连接两个命令, 把前一个命令的输出作为后一个命令的输入
- eg.`cat -n hello.c | grep -n "love"`

## wc
- 作用: 统计一个文件中行数, 单词个数, 大小(字节数)
- 用法: wc [option] [FILE]
- '-l': 只显示行数
- '-w': 只显示单词数
- '-c': 只显示文件的大小

## cut

### 作用: 从一个文本文件或文件流中提取文本列

### 案例: `cut [option] [FILE]`

### 参数

- '-d <分隔符>': 与 '-f' 一起使用
- '-f': 依据 '-d' 的分隔符将一段信息分隔成数段, 用 '-f'取出第极端

### 实例
- `cut -d <分隔符> -f <段数> 文件名`
- `head -1 /etc/passwd | cut -d ":" -f 1,3,4`

## 输入输出流

### 输入重定向
- `命令 < 文件`: 将指定文件的内容作为命令的输入(eg. cat < /etc/passwd>)
- `命令 << 分界符`: 用户在终端的输入作为命令的输入参数, 直到用户输入**分界符**时终止用户输入并作为命令参数输出
- `命令 <文件1> 文件2`: 将文件1的内容作为命令的输入参数, 将命令输出的内容添加到文件2中  
**若文件2存在, 则清空其原内容并替换为命令输出的内容**

### 输出重定向
- `命令 > 文件`: 将命令输出的内容添加到文件中**若文件存在, 则清空其原内容并替换为命令输出的内容**
- `命令 2> 文件`: 如果命令为**错误命令**, 则将其错误内容输入到文件中, **如果文件中已包含数据,则清空原数据写入新数据**
- `命令 >> 文件`: 将命令的输出结果添加到文件的尾部, **不会清空文件内的原有数据**
- `命令 2>> 文件`: 将错误命令的错误提示添加到文件的尾部, **不会清空文件中的原有数据**
- `命令 >> 文件 2>&1`/`命令 &>> 文件`

## 命令置换
- `ehco ls` 与 `echo 'ls'` 或 `echo "$(ls)"` 有区别  
第一个将 ls 理解为字符串, 而后面的 ls 是将其作为指令

## 挂载
- `mount <目标> <挂载目录>`

# 脚本

## 环境变量(/etc/profile)

### 查看环境变量的方式: `env / printenv`

### Linux系统中重要的10个环境变量
- HOME: 用户的主目录
- SHELL: 用户使用的 Shell 解释器名称
- **PATH**: 定义命令行解释器搜索用户执行命令的路径
- EDITOR: 用户默认的文本解释器
- RANDOM: 生成一个随机数字
- LANG: 系统语言 
- HISTSIZE: 输出的历史命令记录条数 
- HISTFILESIZE: 保存的历史命令记录条数

### 访问环境变量方式: `$变量名`

## PATH环境变量

### 通过配置PATH环境变量, 能快速的通过变量名获取内容

### 自定义PATH环境变量方式
- export: `export PATH=$PATH:/home/目标目录名`  
export 定义的环境变量仅当前终端有效, 终端退出后环境该环境消失
- 修改 ~/.bashrc 文件: 对**当前用户**永久有效
- 修改 /etc/profile 文件: 对**所有用户**永久有效

## 脚本编写

### 说明: 1、shell脚本中没有数据类型的概念, 都为字符串<br>2、shell脚本中每一行相当于一条语句, 多条语句应用 ; 分隔开

### 变量定义
- `var=<value>`

### 变量的引用
- $<变量名>

### 单引号和双引号使用变量的区别
- 单引号: 单引号会将内容识别为字符串
- 双引号: 能识别'$', 将其当作变量处理

### 命令置换
- 例. 因为echo 默认会将命令参数识别为字符串, 所以通过  
对命令添加 **反引号 `** 后会将其识别为命令
- eg. `` echo `ls -l` ``

### unset
- 取消变量的定义

### 位置变量
- 使用方式: `./<脚本名> <命令行参数1> ..<命令行参数n>`
- '$0'(预定义变量): 显示终端输入的第一个字符串
- '$num': 第num个**命令行参数**
- '$#': 显示**命令行参数个数**
- '$?': 判断命令执行是否成功, **成功返回0, 否则返回非零**
- '\$@ 或 \$#': 获取所有命令行参数
### 运算与语句 (**等号左右必须空格, 否则视为赋值语句**)

#### **数值运算 若要使用C语法, 则用((C语句))**

##### expr 语句
- `expr $<变量1> <+=\*/%> $<变量2>`: **乘法是反斜杠加星号**
- eg. `` val=`expr $a + $b` ``

##### []
- `$[<变量1><+-*/%><变量2>]`
- eg. `` val=$[$val * 2] `` 

##### let 语句 <==> ((C运算方式))
- 说明: let 语句中**使用变量可以不用添加$**
- eg. `let val=a*b`
- eg. `((a++))` `((val=a+b))`

#### 数值判断
- [ INT1 -eq INT2 ] INT1和INT2两数相等返回为真 ,=
- [ INT1 -ne INT2 ] INT1和INT2两数不等返回为真 ,<>
- [ INT1 -gt INT2 ] INT1大于INT2返回为真 ,>
- [ INT1 -ge INT2 ] INT1大于等于INT2返回为真,>=
- [ INT1 -lt INT2 ] INT1小于INT2返回为真 ,<
- [ INT1 -le INT2 ] INT1小于等于INT2返回为真,<=

#### 布尔运算符
- '!': 非运算
- '-o': 或运算
- '-a': 与运算

#### 逻辑运算
- [ ! EXPR ] 逻辑非，如果 EXPR 是false则返回为真。
- [ EXPR1 -a EXPR2 ] 逻辑与，如果 EXPR1 and EXPR2 全真则返回为真。
- [ EXPR1 -o EXPR2 ] 逻辑或，如果 EXPR1 或者 EXPR2 为真则返回为真。
- [ ] || [ ] 用OR来合并两个条件
- [ ] && [ ] 用AND来合并两个条件

#### 字符串判断
- [ -z STRING ] 如果STRING的长度为零则返回为真，即空是真
- [ -n STRING ] 如果STRING的长度非零则返回为真，即非空是真
- [ STRING1 ]　 如果字符串不为空则返回为真,与-n类似
- [ STRING1 == STRING2 ] 如果两个字符串相同则返回为真
- [ STRING1 != STRING2 ] 如果字符串不相同则返回为真
- [ STRING1 < STRING2 ] 如果 “STRING1”字典排序在“STRING2”前面则返回为真。
- [ STRING1 > STRING2 ] 如果 “STRING1”字典排序在“STRING2”后面则返回为真。

#### **文件判断**
- [-e FILE ] 判断文件是否存在
- -f 文件是否为普通文件
- '-d': 文件是否为一个目录
- '-r': 文件是否可读
- '-w'
- '-x'
- eg. `test -f <文件> <==> [ -f <文件> ]`
#### echo

##### 显示普通字符串
- `echo "hello world"`
- `echo hello world`

##### 显示转移字符
- `echo "\" hello world "\"`
- '-e 参数'(开启转义): `echo -e "hello\n"` 

##### 不换行显示
- '-c 参数': `echo -c "hello"`
- '-n 参数': `echo -n "hello"`

##### 原样输出字符串, 不转义或取变量值
- '使用单引号': `echo '$value' --> $value` 

#### test语句(测试语句) <==> [空格 内容 空格](**注意!!! 中括号两边一定有空格**)
##### eg. `test 123 -eq 456 <==> [ 123 -eq 456 ]`
##### 参数
###### 数值测试
- `test <$变量1> <关系运算符> <$变量2>`
###### 字符测试
- `test <$变量1> <字符串运算符> <$变量2>`

#### 语句

##### if
- eg.  
```
if test $1 -eq $2 <==等价于> if [ $1 -eq $2 ]
# 多条件判断
if [ condition1 ] || [ condition2 ]
then
  command
elif <condition>
then
  command1
  command2
else
  command (注意: 对于shell的else不能空语句)
fi
```

##### case
- eg.  
```
case <$变量> in
  "<target1>")
    command1
    ;;        #这里的 ;; 相当于 break
  "<target2>")
    command2
    ;;
  *)          # 这里的*)相当于 default
    command
esac
```

##### for
- eg.
```
for <value> in <list> # list 中的值用空格隔开, 也可以是$@
do
  command
done
```

##### while
- eg.  
```
while [ comdition ]
do
  command
done
```